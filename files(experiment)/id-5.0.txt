# LIGA — Linearized Integer Geometry Architecture

Github : https://github.com/nahhididwin/LIGA/

**Kiến trúc hình học số nguyên tuyến tính**


# Tóm tắt (Abstract)



LIGA (Linearized Integer Geometry Architecture) là một khuôn lý thuyết + kiến trúc nhằm mã hoá mọi thực thể hình học rời rạc hữu hạn (tile, voxel, octree node, v.v.) vào một số nguyên lớn duy nhất
$$\mathbb{L}$$ theo quy ước PFE (Polar Frame Encoding). Bằng cách thiết kế layout bit với các phân đoạn độc lập (Guard, State, Radius, Phase), ta có thể diễn đạt các phép biến đổi hình thái (Boolean/CSG, translation, rotation rời rạc, scaling via log-encoding) dưới dạng các thao tác số nguyên nguyên thủy (shift, bitwise, add modulo theo phân đoạn) và đưa ra điều kiện cần-đủ để những phép toán đó tương đương chính xác với phép toán hình học mong muốn.


Trong văn bản này tôi:

1. Định nghĩa chính xác không gian, ánh xạ $$\mathcal{F}$$ và PFE (độ dài, offset các phân đoạn).

2. Phát biểu và chứng minh các định lý: injectivity, tính đúng đắn CSG, điều kiện không-carry (guard-safe) và tính đúng đắn của rotation bằng mask-add, tính chất scaling qua mã hoá log, tính đảo ngược (reversibility) có điều kiện khi dùng ECC.

3. Mô tả mô hình lỗi và các cơ chế giảm lỗi (guard, ECC, RNS, dithering) với chỉ dẫn rõ ràng để lựa chọn tham số sao cho các điều kiện chứng minh thỏa.

4. Trình bày phương pháp xây dựng UWR (Ultra-Wide Register) và MPU (Morphological Processing Unit) một cách xây dựng: cách tổ chức thanh ghi rất rộng bằng các phần tử phần cứng hiện có (block RAM, LUT, DSP, multi-word buses), mảng cộng song song phân đoạn, barrel shifter matrix, và mapping thực tế lên FPGA như một prototype khả thi (các bước, thuật toán, ước lượng tài nguyên biểu thức).

5. Đưa ra lộ trình thí nghiệm chi tiết kèm tập dữ liệu, kiểm định điều kiện lý thuyết, inject-fault tests, và phép so sánh đối chứng (GPU, vectorized CPU).

6. Trình bày các kịch bản ứng dụng, hạn chế, trade-offs, và các bằng chứng luận lý cho mọi khẳng định.

Kết luận: LIGA có tiềm năng trở thành một lối tiếp cận mạnh cho các bài toán hình thái rời rạc n-chiều, khi và chỉ khi (i) đối tượng bài toán thỏa 3 điều kiện đã nêu (rời rạc, biến đổi đồng loạt, chú trọng topology), và (ii) kiến trúc UWR/MPU được triển khai sao cho thỏa các điều kiện guard/ECC/RNS. Tôi cung cấp đủ công thức, chứng minh và lộ trình để kiểm chứng thực nghiệm những tuyên bố này.



# Nội dung chi tiết

**1. Định nghĩa cơ bản, ký hiệu**

$n$ — số chiều (có thể $n \geq 1$).

Một lưới rời rạc $G$ có $d$ bit theo mỗi chiều (kích thước $2^d$ per-dimension). Tổng ô $= 2^{d \cdot n}$.

Mỗi frame: một đơn vị packing dùng để mô tả một tile/hypervoxel/ô trong cây (octree node) — chứa các trường: Phase $\phi$ (vòng pha rời rạc), Radius $\rho$, State $S$ (trạng thái vật liệu), và Guard $Gd$.

Ký hiệu $W =$ tổng số bit của một PFE; $N =$ số PFE đóng gói trong $\mathbb{L}$. Do đó $\mathbb{L} \in \{0, \dots, 2^{NW} - 1\}$ và

$$\mathbb{L} = \sum_{k=0}^{N-1} \text{PFE}_k \cdot 2^{kW}.$$

Mỗi PFE có phân đoạn bit (từ LSB $\to$ MSB): $\phi$ (width $\varphi$), $\rho$ (width $r$), $S$ (width $s$), $Gd$ (width $g$), với $g + s + r + \varphi = W$.

Offset of $\phi$ in PFE: $o_\phi$ (LSB position).

Trong phần sau, khi viết "thêm $v$ vào phân đoạn $\phi$", tôi hiểu đó là thêm theo modulo $2^\varphi$ và thực hiện bằng một phép cộng toàn chuỗi trên $\mathbb{L}$ với một mặt nạ $M(v)$ đã được định nghĩa.

**2. Ánh xạ $\mathcal{F}$ và tính injective**

Định nghĩa 2.1 (Packing $\mathcal{F}$). Với một bộ frame $F = \{\text{PFE}_0, \dots, \text{PFE}_{N-1}\}$, định nghĩa $\mathcal{F}(F) = \sum_{k=0}^{N-1} \text{PFE}_k \cdot 2^{kW}$.

Định lý 2.1 (Injectivity). Cho hai cấu trúc occupancy $A, B$ trên cùng grid/pacing và cùng quy ước packing. Nếu tồn tại ít nhất một ô $i$ sao cho $o_A(i) \neq o_B(i)$ thì $\mathcal{F}(A) \neq \mathcal{F}(B)$.

Chứng minh. Vì quy ước packing cố định ánh một ô cụ thể tới một bit cụ thể trong một PFE cố định, khác biệt occupancy tại ô $i$ làm thay đổi bit tương ứng trong PFE tương ứng. Do phép đóng gói là phép ánh xạ tuyến tính trên bit-positions (với cơ số 2) nên hai biểu diễn phải khác nhau. $\square$

Đây là bằng chứng đơn giản nhưng quan trọng: injectivity phụ thuộc vào quy ước packing không đổi. Nếu packing thay đổi giữa hai biểu diễn thì injectivity không còn đảm bảo — điều này phải được cảnh báo trong thực nghiệm.

**3. CSG và tính chính xác**

Định lý 3.1 (CSG chính xác bằng bitwise logic). Với quy ước packing 1-bit per cell (mỗi ô tương ứng một bit occupancy), các phép toán tập rời rạc chuẩn (union/intersection/difference) tương đương đúng đắn với các phép toán bitwise trên $\mathbb{L}$:

$$\mathbb{L}_{A \cap B} = \mathbb{L}_A \ \& \ \mathbb{L}_B, \quad \mathbb{L}_{A \cup B} = \mathbb{L}_A \ | \ \mathbb{L}_B, \quad \mathbb{L}_{A \setminus B} = \mathbb{L}_A \ \& \ \neg \mathbb{L}_B.$$

Chứng minh. Mỗi bit là chỉ thị occupancy, và các phép toán tập Boolean tương ứng bit-wise. Do đó trên không gian toàn bộ bit-positions, phép toán tập tương đương phép toán logic bit. $\square$

Hệ quả thực nghiệm: cho bất kỳ cài đặt phần mềm/hardware nào thực hiện bitwise ops trên cùng ordering, các phép CSG là chính xác tuyệt đối (không tồn tại lỗi làm sai vị trí nào) — miễn là các bit không bị lỗi (bit-flip) trong quá trình.

**4. Guard-safety: điều kiện tránh carry cross-segment — chứng minh toán học**

Mục tiêu: khi ta thực hiện phép cộng mặt nạ $M(v)$ (cộng $v$ vào trường $\phi$ của mọi PFE cùng lúc bằng một phép cộng trên toàn $\mathbb{L}$), chúng ta cần đảm bảo không có carry làm thay đổi các phân đoạn khác của cùng PFE hoặc lan sang PFE bên cạnh.

**4.1 Mô tả carry chain**

Khi cộng hai số nguyên, carry có thể propagate từ bit thấp lên bit cao qua nhiều bit liên tiếp.

Nếu trong PFE ta chia thành phân đoạn liên tiếp, để cô lập phép cộng trong một phân đoạn cần đảm bảo rằng carry không vượt ra khỏi vùng dự phòng (guard).

**4.2 Điều kiện đơn giản (sufficiency)**

Định nghĩa (Guard-safe layout). Gọi $C_{\max}$ là giá trị lớn nhất có thể phát sinh ở tổng của trường $\phi$ cộng các phép cộng chồng (ví dụ nếu áp dụng tối đa $t$ lần cộng $v$ liên tiếp trước khi kiểm tra/reset), thì nếu:

$$2^\varphi (\text{modulus}) \times t \leq 2^\varphi \cdot t \leq 2^\varphi \cdot (2^g - 1)$$

hay tương đương,

$$g > \lfloor \log_2 (C_{\max} / 2^\varphi) \rfloor$$

thì guard có đủ bit để chứa mọi carry không cho phép lan sang phân đoạn tiếp theo. Cách phát biểu đầy đủ hơn:

Điều kiện (sufficient): nếu mọi phép toán cộng trên phân đoạn $\phi$ có tổng tại mỗi PFE nằm trong khoảng $[0, 2^\varphi - 1 + R]$ với $R$ là tổng carry tạm thời tối đa, và nếu $R < 2^g$ thì carry không thể đặt 1 vào bất kỳ bit nào bên ngoài trường guard (vì guard có ít nhất $g$ bit đặt để nhận carry). Do đó vùng State/Radius/next-PFE không bị ảnh hưởng.

**Chứng minh (phác thảo "carry bounding")**

Khi cộng $M(v)$ trên toàn $\mathbb{L}$, mỗi PFE nhận một cộng $v$ vào trường $\phi$. Giá trị trước addition tại PFE $k$ là $x_k \in [0, 2^\varphi - 1]$. Sau addition và modulo $2^\varphi$ nội bộ, carry ra khỏi trường $\phi$ có giá trị $c_k = \lfloor (x_k + v) / 2^\varphi \rfloor \in \{0, 1, \dots \}$. Khi tổng số phép cộng chồng tối đa (hoặc khi các phép cộng được thực hiện liên tiếp trước khi làm sạch) là $t$, tổng carry tích lũy tối đa vào vùng guard là $\leq c_{\max} t$ với $c_{\max} \leq \lceil v / 2^\varphi \rceil$. Nên nếu guard có thể biểu diễn mọi giá trị carry tích lũy (tức $2^g - 1 \geq$ tổng carry), carry sẽ bị chứa trong guard và không làm bốc bit ở phân đoạn kế tiếp. Vì vậy guard-safety đảm bảo isolation. $\square$

Lưu ý thực tế: công thức chính xác của $C_{\max}$ phụ thuộc chiến lược thực hiện (single global addition với modulo $2^{NW}$ hay successive small adds) — trong thực nghiệm bạn phải tính $t$ và $v$ cụ thể.

**4.3 Điều kiện cần thiết**

Nếu guard quá nhỏ để chứa carry tích lũy, tồn tại bộ khởi tạo PFE sao cho carry sẽ lan sang phân đoạn bên cạnh và thay đổi state/ radius; do đó guard-safety là cần nếu bạn muốn không có thay đổi cross-segment trong mọi trường hợp. Tuy nhiên, nếu bạn có kiểm soát ngặt việc thực hiện phép cộng (ví dụ chỉ thực hiện khi biết $x_k + v < 2^g$ cho mọi $k$) thì guard có thể nhỏ hơn; đó là trade-off.

**5. Rotation bằng mask-add: định lý và chứng minh chặt chẽ**

Định nghĩa (Phase mask). Với một giá trị pha rời rạc $v \in [0, 2^{\varphi} - 1]$, định nghĩa

$$M(v) = \sum_{k=0}^{N-1} v \cdot 2^{kW+o_{\phi}}.$$

(Đây là số nguyên có cùng trường $\phi$ của mỗi PFE đặt bằng $v$.)

Định lý 5.1 (Rotation bằng addition toàn cục). Nếu layout là guard-safe theo định nghĩa ở trên và phép toán được thực hiện bằng một phép cộng toàn cục

$$\mathbb{L}' = (\mathbb{L} + M(v)) \bmod 2^{NW},$$

thì với mỗi PFE $k$, trường $\phi$ của $\text{PFE}_k$ được cập nhật đúng bằng

$$\phi'_k = (\phi_k + v) \bmod 2^{\varphi},$$

và các phân đoạn khác (state, rho, guard) không thay đổi (ngoại trừ phần guard chứa carry). Nghĩa là phép toán tương đương với "xoay rời rạc" mọi frame cùng lúc.

Chứng minh.

Viết $\mathbb{L} = \sum_k p_k 2^{kW}$ với $p_k \in [0, 2^W - 1]$ là mỗi PFE dưới dạng integer. Mặt nạ $M(v)$ viết được dưới dạng $\sum_k v 2^{kW+o_{\phi}}$.

Ở mỗi PFE, addition $p_k + v \cdot 2^{o_{\phi}}$ chỉ tác động lên các bit trong dải $[o_{\phi}, o_{\phi} + \varphi - 1]$ và có thể tạo carry sang các bit trên (vùng guard nằm bên trên). Nếu guard-safety đảm bảo carry sẽ dừng trong guard và không tạo carry sang phân đoạn state/rho của cùng PFE, thì phần state/rho giữ nguyên.

Do phép cộng cộng đồng (global integer add) tương đương nối các phép cộng độc lập tại từng PFE kèm propagate carry giữa PFE $k$ và $k+1$ chỉ khi overflow qua $W$-bits xuất hiện. Nếu ta thực hiện modulo $2^{NW}$ và bố cục PFE liên tiếp, overflow từ PFE $k$ sang PFE $k+1$ sẽ chỉ xảy ra nếu total carry vào bit $kW + W$ là $\ge 1$. Nhưng với guard đủ dài để chặn mọi carry đã giới hạn, overflow không xảy ra.

Kết luận: mỗi $\phi_k$ được cộng modulo $2^{\varphi}$ độc lập. $\Box$

**6. Scaling bằng mã hoá log (chứng minh toán học)**

Định lý 6.1 (Scaling $\approx$ addition trên mã hóa log). Giả sử bạn mã hoá bán kính bằng một số nguyên rời rạc $\tilde{\rho} = \text{enc}(\ln \rho)$ sao cho $\text{dec}(\tilde{\rho})$ là một hàm xấp xỉ $\exp$ của $\tilde{\rho}$. Khi đó nhân bán kính bởi konst $s > 0$ tương đương cộng hằng số vào $\tilde{\rho}$:

$$\text{enc}(\ln(s\rho)) = \text{enc}(\ln s + \ln \rho) \approx \text{enc}(\ln s) + \tilde{\rho},$$

với sai số $\le$ nửa bước mã hóa (quantization error).

Chứng minh (lôg-linearity). Trivial từ log: $\ln(s\rho) = \ln s + \ln \rho$. Nếu $\text{enc}$ là một ánh xạ tuyến tính (hoặc tuyến tính từng đoạn) từ $\ln(\cdot)$ về số nguyên, thì phép nhân biến thành phép cộng với sai số do rời rạc hoá. Độ lớn sai số có thể phân tích: nếu $\text{enc}$ là $\tilde{\rho} = \lfloor \alpha \ln \rho + \beta \rceil$ thì sai số $\le 1/2$ (đơn vị mã hóa). $\square$

Lưu ý: điều này chỉ hữu dụng khi ứng dụng chấp nhận sai số multiplicative nhỏ do rời rạc hoá — phù hợp với các bài toán topology/occupancy, không phù hợp khi cần metric chính xác.

**7. Reversibility có điều kiện qua ECC (chứng minh)**



Định nghĩa (ECC block). Mỗi PFE mang thêm một trường guard chứa mã sửa lỗi block-code (ví dụ BCH hoặc LDPC) có độ dài $g$ bit, mã có khoảng cách Hamming $d_{\min}$, sửa được $t = \lfloor (d_{\min} - 1)/2 \rfloor$ lỗi trong block đó.

Định lý 7.1 (Reversibility có điều kiện). Cho một chuỗi phép toán $T$ từ $\mathbb{L}_0$ đến $\mathbb{L}_f$ gồm các thao tác bitwise, shift, add-modulo cục bộ thỏa guard-safe; nếu trong suốt chuỗi này, số bit lỗi không kiểm soát trong mỗi block $\le t$ tại mọi thời điểm trước khi đảo ngược, thì ta có thể phục hồi trạng thái ban đầu bằng cách: (i) dùng ECC để sửa lỗi ở mỗi bước hoặc (ii) sửa lỗi sau khi hoàn tất chuỗi, rồi áp dụng các phép toán nghịch đảo tuần tự.

Chứng minh (ý chính). Các phép toán bitwise/shift/add (khi guard-safe) là ánh xạ toàn đồ (bijective) trên không gian giá trị hợp lệ (tức không có lỗi trong bit payload), hoặc ít nhất là injective nếu ta biết lịch sử thao tác. Nếu $\text{errors} \le t$ trong mỗi block, ECC sẽ khôi phục block về giá trị hợp lệ (nhãn trước biến đổi). Do đó sau khi sửa lỗi, ta có thể áp dụng phép nghịch đảo toán học (subtraction modulo, shift ngược, bitwise inverse) để phục hồi $\mathbb{L}_0$. $\square$

Thực nghiệm: đảm bảo điều kiện "$\text{errors} \le t$ tại mọi thời điểm" là nhiệm vụ của cơ chế phát hiện/giới hạn lỗi — ví dụ bằng redundancy, parity checks thường xuyên, hoặc cơ chế rollback checkpoints.

**8. RNS (Residue Number System) và tính tránh carry — lời giải toán học + thực hành**

8.1 Lý thuyết RNS ngắn

Chọn moduli $m_1, \dots, m_k$ pairwise coprime, tổng miền biểu diễn tới sản phẩm $M = \prod_{i} m_i$.

Một số $X$ được biểu diễn qua residues $(x_1, \dots, x_k)$ với $x_i = X \pmod{m_i}$.

Các phép cộng/trừ trong RNS thực hiện độc lập trên từng modulus — không có carry giữa residues $\to$ phù hợp cho add throughput cao.

Ưu-nhược: RNS cho phép cộng nhanh, không carry, nhưng phép so sánh/scale/CRC cần chuyển đổi CRT (Chinese Remainder) hoặc các thuật toán so sánh RNS phức tạp.

8.2 Ứng dụng trong LIGA

Đối với trường radius hoặc các trường cần dynamic range lớn nhưng ít phép so sánh, lưu theo RNS bên trong PFE (chia thành nhiều sub-fields được hiểu là residues) giúp tránh carry chain khi cộng các offset lớn. Việc encode/decode RNS cần routines CRT/GA, tôi cung cấp thuật toán chuyển đổi nhanh (Garner's algorithm) và ước lượng độ phức tạp $O(k^2)$ naive hoặc $O(k \log^2 M)$ nếu dùng FFT-based modular multiplications.

Hướng dẫn thực hiện: trong thiết kế hardware, mỗi modulus có thể được xử lý bằng mảng adder nhỏ độc lập; lưu trữ residues trong vùng lưu trữ phân đoạn và sửa lỗi độc lập.

**9. Mô hình lỗi, ECC chi tiết & chiến lược chọn tham số (hướng dẫn thực hiện)**

9.1 Mô tả nguồn lỗi

Soft errors (bit flips): tỷ lệ lỗi $p$ per bit/time.

Hard errors (permanent stuck bits): cần detect + retire.

Arithmetic overflow/carry (do guard thiếu): dẫn đến corruption lớn.

Quantization error (rời rạc hóa encoding): là sai số chấp nhận được trong topology tasks.

9.2 Lựa chọn ECC

Nếu mục tiêu: bảo vệ chống $\le t$ lỗi per-PFE giữa 2 checkpoints, chọn BCH/RS hoặc LDPC với thông số $(n, k, t)$.

Thiết kế tham số:

Dự trữ $g$ bits guard = ECC parity bits + slack bits để cô lập carry.

Chọn $t$ dựa trên $p$ (tỷ lệ lỗi), chu kỳ giữa các checks $T_c$, và số bit per block $n$: đảm bảo $P(> t \text{ lỗi}) \ll \epsilon$ theo yêu cầu tin cậy. (Xác suất có thể ước lượng bằng phân phối binomial hoặc Poisson.)


Thực hiện: sử dụng BCH cho block size $\le$ few Kbits, hoặc LDPC cho block lớn với decoder sum-product trong hardware.

9.3 Dithering / oversampling bit-domain

Khi rời rạc hóa góc/phases gây aliasing, thực hiện oversampling internal: lưu oversampled phase (ví dụ nhiều sub-phase) và trộn bit error bằng bit-shuffle $\rightarrow$ hiệu ứng tương tự noise trắng. Sau đó lọc (về phép phi tuyến học) làm mượt artifacts. Đây là phương pháp engineering để giảm artifacts rời rạc.

**10. Kiến trúc MPU và cách xây dựng UWR — hướng dẫn kỹ thuật đầy đủ (constructive)**


Mục tiêu ở đây: đưa ra phương pháp cụ thể, đủ chi tiết để một đội kỹ sư FPGA/ASIC có thể triển khai prototype UWR/MPU. Tôi trình bày thiết kế theo cấp độ mô-đun, kèm thuật toán, mapping sang phần tử FPGA/ASIC và ước lượng công thức tài nguyên.

Lưu ý: "UWR" (Ultra-Wide Register) không phải một phép màu; kỹ thuật xây dựng thực hiện bằng cách kết hợp nhiều thành phần lưu trữ nhỏ hơn (words) cùng với logic thao tác song song. Tôi trình bày cách xây dựng tập-hợp các registers rất rộng bằng chunking + wide arithmetic units + barrel shifter matrix.

10.1 Thiết kế tổng quan (block diagram)

Các module cơ bản:

Storage (UWR store): $\text{UWR} = \text{concat}(W \text{ bits})$; thực hiện bằng $C = \lceil W / w_{phy} \rceil$ words vật lý (ví dụ $w_{phy} = 64$ bit). Mỗi word lưu chunk $k$ của UWR.

Bitwise Engine: thực hiện $\text{AND/OR/NOT}$ trên từng word, hoạt động song song trên $C$ words.

Phase Adder Array (segmented): thực hiện add modulo trên mỗi phân đoạn $\phi$ của mỗi PFE. Thiết kế theo mô-đun: $\text{per-chunk adder} + \text{carry-isolation}$.

Barrel Shifter Matrix: hỗ trợ dịch lớn (khi dịch offset nhiều bit) — được thực hiện bằng tổ hợp $\text{barrel shifters per-chunk}$ và $\text{cross-word routing}$.

RNS/ECC Unit: module for residue conversions and $\text{ECC encode/decode}$.

DMA/Compression unit: streaming nén/giải nén $\text{octree / sparse streams}$.

10.2 Chi tiết xây dựng UWR bằng chunking

Ý tưởng: lưu $W$-bit register bằng $C$ words $w_{phy}$ (ví dụ 64-bit forms). Mọi phép bitwise là thao tác độc lập trên từng word $\rightarrow$ latency $O(1)$ từ view clock cycles (mỗi word thao tác 1 cycle; có thể pipeline). Đối với addition toàn UWR, ta cần multiword adder.

Thiết kế multiword adder không-carry-chain-mắc-nợ:

Truyền thống: multiword ripple-carry adder có carry chain qua words (chậm). Khắc phục: dùng carry-save adders (CSA) tree hoặc carry-lookahead/Kogge-Stone cho multiword, hoặc thực hiện addition theo phân đoạn (segment-wise) do chúng ta chỉ cần add vào các phân đoạn $\phi$ nhỏ hơn $W$.

Segmented addition approach (đề xuất):

Chia $W$ thành per-PFE vùng (mỗi PFE $W$ bits). Mỗi PFE chứa $\phi$ ở offset cố định.

Khi cần add $M(v)$: tổ chức adder chỉ xử lý word chunks có chứa bits $\phi + \text{guard region}$; các chunk khác chỉ pass-through.

Sử dụng local ripple adder trong mỗi chunk, nhưng guard đủ rộng để carry không lan sang chunk kế $\rightarrow$ total latency = $\text{number of words covering } (\phi + \text{guard}) \times \text{adder latency}$.

Ưu điểm: latency thấp hơn so với addition toàn $W$ nếu $\phi$ small relative to $W$; hardware reuse.

Tỉ lệ pipelining / throughput: thực hiện addition pipelined trên nhiều stage (chunk-level), cho throughput 1 add per cycle sau pipeline fill (với resource tradeoff).

10.3 Barrel Shifter Matrix — xây dựng

Dịch một UWR theo offset $o$: thực hiện bằng dịch trên mỗi word cộng cross-word routing. Barrel shifter matrix có thể được cấu thành bởi mạng muxes/rotators giữa words. Latency $\sim O(\log C)$ theo việc dùng tree mux. Trong FPGA, dùng routing LUT để xây barrel shifter. Nếu nhiều dịch đồng thời (vector of shifts), thiết kế thành mảng shifters.

10.4 Phase Adder Array — mảng cộng song song

Thiết kế một array gồm $N$ small adders (mỗi add modulo $2^\phi$) hoạt động song song — nhưng triết lý LIGA là thực hiện một add duy nhất lớn thay vì $N$ adds; trong hardware, ta triển khai effect same bằng việc kết hợp mảng adders nhỏ hoặc multiword addition optimized để chỉ xử lý segment $\phi$.

Implementation choices:

If $\phi \le w_{phy}$: mỗi $\phi$ nằm trong một hoặc hai words $\rightarrow$ dùng $N$ parallel small adders operating on packed residues (SIMD within word) — cần nhiều logic.

Nếu $N$ lớn, bạn chunk $N$ into groups per word and operate in parallel across words.

10.5 Mapping lên FPGA (prototype thực tế — hướng dẫn từng bước)

Bước 1 — Chọn chunk width $w_{phy}$: typical $32/64$ bits (tùy FPGA memory interface).

Bước 2 — Layout memory: store $\mathbb{L}$ as array of words in BRAM or URAM (Xilinx naming) in contiguous addresses so DMA can stream chunk sets into processing pipeline.

Bước 3 — Implement bitwise engine: per-word LUT logic for AND/OR/NOT $\rightarrow$ trivially parallel.

Bước 4 — Implement segmented add: for each word that covers $\phi + \text{guard region}$, implement ripple adder using FPGA fast carry chain (CARRY4) to minimize LUT use; ensure guard size chosen so that carry does not propagate across physical word boundary (or use explicit inter-word carry path if needed).

Bước 5 — ECC/RNS: implement decode/encode in logic or soft-processor; for LDPC, prefer dedicated hardware decoder; for BCH small blocks, use lookup or Berlekamp–Massey + Chien search hardware.

Bước 6 — DMA and scheduler: implement streaming so that UWR is loaded chunk by chunk; processing pipeline applies mask-add or bitwise ops; store back.

Ước lượng tài nguyên (công thức):

Bits memory $= N \cdot W$

Words $= N \cdot \lceil W / w_{phy} \rceil$

For per-word bitwise ops:

$\text{LUTs} \approx k_1 \cdot \text{Words}$ ($k_1$ depends on operations)

$\text{BRAMs} \approx \lceil \text{Bits} / \text{BRAM\_size} \rceil$

Adders: to support add on $S$ words per cycle, need approx $S$ fast adder slices; latency per add $\approx L_{adder} \cdot \text{chunks covering } \varphi + g$.

(Đây là dạng công thức để ước lượng — cụ thể số LUT/BRAM/DSP tùy FPGA chọn.)

Tôi không đưa số tuyệt đối (số LUT/BRAM cụ thể) vì phụ thuộc FPGA model; thay vào đó cung cấp công thức tính để bạn chèn thông số thực tế của board mục tiêu.

10.6 Lập trình ISA mẫu và microcode

Đề xuất tập lệnh MPU (mô tả chức năng):

LOAD_UWR(addr, W) — load UWR từ memory (stream).

STORE_UWR(addr, W) — store back.

ROTATE_MASK_ADD(v, o_phi, phi_bits) — perform mask add.

BLOCK_SHIFT(offset) — block shift using barrel shifter matrix.

BITWISE_AND/OR/NOT(block_mask) — apply bitwise to selected chunks.

ECC_CHECK(block_id) — run ECC decode.

RNS_ADD(mod_index, value) — add in residue domain.

Microcode: ROTATE_MASK_ADD thực hiện:

1. stream chunks covering $\phi + g$ vào adder pipeline,

2. per chunk: add small adders, store carry in guard field,

3. write back.

**11. Độ phức tạp & băng thông — công thức chứng minh**

11.1 Notations

$m =$ total bits to process,

$W =$ UWR width,

$C = \lceil m/W \rceil =$ number of chunks,

$B_{mem} =$ memory bandwidth (bits/s),

$T_{comp} =$ computation cycles per chunk operation.

11.2 Latency / throughput model

If $m \le W$: one chunk $\rightarrow$ compute time $\approx t_{uwr}$ (hằng số thiết kế) — tức $O(1)$.

If $m > W$: need $C$ chunks $\rightarrow$ time $\approx C \cdot (t_{io} + t_{comp})$.

Bounded speedup over pairwise per-frame operations: nếu baseline executes per-frame ops requiring access to each frame separately, LIGA approach reduces memory passes (khi packing nhiều frame trong một UWR) — speedup factor $\approx$ ratio of baseline memory accesses to LIGA memory accesses. Công thức cụ thể phụ thuộc packing density.

Băng thông yêu cầu: to sustain throughput of $R$ operations/s on objects of size $m$, need memory bandwidth $\ge R \cdot m$.

**12. Giao diện rendering: Bit $\rightarrow$ Pixel + Neural Bit Decoder (thiết kế & chứng minh mô tả)**

Bit $\rightarrow$ Pixel deterministic pipeline: quét bit-tiles theo Hilbert/Morton order, tạo tile framebuffer. Đây là chuyển đổi thuần logic/lookup; tính đúng đắn dễ kiểm tra bằng mapping bit positions $\rightarrow$ pixel positions.

Neural Bit Decoder (NBD): mô hình học (CNN) lấy patch bit (ví dụ $32 \times 32$ binary patch) và tạo output RGB tile. Tôi trình bày kiến trúc mẫu ($3\times$ conv + upsample + residuals) và metric (SSIM, LPIPS). NBD không là phần bắt buộc của LIGA; nó là module tùy chọn để chuyển từ topology bit $\rightarrow$ texture mượt mà.

**13. Hạn chế, trade-offs (phân tích chặt chẽ)**

Curse of dimensionality: số ô tăng theo $2^{d \cdot n}$ — LIGA không phá bỏ độ tăng này, chỉ giúp xử lý song song và biểu diễn; cần sparsity / hierarchical structures (octree) để khả thi.

Chi phí I/O: nếu $m$ quá lớn, I/O (DRAM) mới là cổ chai; cần streaming, compression.

Precision vs topology: nếu ứng dụng cần metric chính xác (phép nội suy, shading perspective-correct), LIGA không phù hợp trực tiếp.

Hardware cost: UWR/MPU yêu cầu routing và resources nhiều; trade-off giữa throughput và cost.

**14. Lộ trình thí nghiệm & benchmark: đầy đủ, có thể thực hiện ngay**

Tôi liệt kê các bước thực hiện (chi tiết để lặp lại) nhằm kiểm chứng mọi mệnh đề:

Giai đoạn 0 — Chuẩn bị datasets & baseline

Datasets: voxelized Stanford Bunny (các độ phân giải: $128^3, 256^3, 512^3$), CAD boolean models (CSG heavy), synthetic high-dim sparse/hypervoxel nD data (n=4,5 thử nghiệm kích thước nhỏ), octree test scenes.

Baselines: GPU sparse voxel engine (CUDA), CPU vectorized numpy implementation, pure per-frame python loop. Mục tiêu: đo latency/op, memory, energy simul.

Giai đoạn A — Reference software (6–8 tuần)

Implement LIGA::pack/unpack, build_phase_mask, apply_rotation_mask như script mẫu; kiểm tra correctness với random tests (unpack sau khi operations).

Implement guard-safety analyzer: simulate sequences of operations và check carry events (count if any bit outside guard flips).

Implement ECC simulate: inject faults (random bit flips), run ECC decode and check recovery rate. Tính empirical P(recover).

Metrics: per-op latency, throughput, memory footprint, Hamming distance vs ground truth.

Giai đoạn B — RNS/ECC validation (6–8 tuần)

Implement RNS arithmetic modules; measure speed vs big integer addition; evaluate cost of CRT decode.

Fault injection: inject random bit flips at rates simulating radiation/soft errors; measure ECC decode success vs $t$, compute probabilities and choose $g$ accordingly.

Giai đoạn C — FPGA prototype (12–20 tuần)

Target: mid-range FPGA (một board development). Implement UWR as chunked BRAM + logic pipeline.

Implement Barrel shifter, segmented adder pipeline, ECC decoder (BCH).

Measure throughput, latency, energy (if board instrumented), and compare end-to-end with GPU baseline for CSG/rotation workloads.

Verify guard-safety empirically by applying many mask-adds and checking for cross-segment corruption.

Giai đoạn D — End-to-end pipeline & NBD (8–12 tuần)

Integrate NBD for Bit $\to$ Pixel path; measure SSIM/LPIPS vs rasterization; measure latency.

For nD tests, measure wall time to apply global rotation offset on all frames vs baseline.

**15. Ví dụ numeric minh hoạ carry/guard (mở rộng)**

Cho ví dụ cụ thể để chứng minh guard-safety:

$W=64, \text{phi\_bits } \varphi = 10, rho=12, state=6 \Rightarrow \text{guard } g=36$.

$v=200, \text{max stacked additions } t=10 \Rightarrow \text{worst carry into guard } \leq \lceil (2^{10} - 1 + 200 \cdot 10) / 2^{10} \rceil =$ compute exactly:

$\max \phi \text{ initial} = 2^{10} - 1 = 1023$

after adding $200 \cdot 10 = 2000 \to 3023 \to \text{carry count} = \lfloor 3023 / 1024 \rfloor = 2$. Carry into guard $\leq 2$.

Guard $g=36$ can store values up to $2^{36} - 1 \gg 2 \to \text{safe}$.

Áp dụng công thức của phần 4, ta thấy guard đủ lớn để cô lập carry.

**16. Những mệnh đề không hoàn toàn có chứng minh (và cách chứng minh chúng)**

Một vài tuyên bố thực nghiệm kiểu “LIGA có thể nhanh hơn GPU cho workloads voxel-heavy” là khẳng định cần kiểm chứng. Tôi không chứng minh được một kết luận global vì:

Nó phụ thuộc vào nhiều tham số (sparsity, $W, N$, I/O bandwidth, FPGA/ASIC vs latest GPU).

Tuy nhiên tôi cung cấp bộ thí nghiệm và metrics để kiểm chứng. Cụ thể, để chứng minh (hoặc phủ định) câu này, thực hiện: (i) lấy workloads representative, (ii) triển khai prototype FPGA MPU theo hướng dẫn, (iii) đo latency/throughput/energy, (iv) so sánh với GPU chuyên dụng dùng best practice. Kết quả thực nghiệm sẽ đưa ra kết luận.

**17. Toàn bộ pseudocode, test suites, và cách tái tạo experiment (chi tiết)**

Tôi cung cấp pseudocode chính mở rộng (bản rút gọn vì bạn đã có mã Python mẫu). Hướng dẫn reproducibility:

Cài đặt môi trường Python (3.9+), numpy, pytest.

Clone repository (github link bạn cung cấp).

Thêm tests:

test_pack_unpack: random frames → pack → unpack → compare.

test_mask_add: apply mask add iterations → unpack → compare with per-frame vectorized update.

test_guard_violation: generate adversarial frames to attempt to produce cross-segment carry; check detection.

fault_injection_test: flip random bits in $\mathbb{L}$ $\to$ run ECC decode $\to$ check recovery.

Tôi đã mở rộng mã mẫu trong phần appendix của bạn; bạn có thể dùng test harness đó làm base.

**18. Kết luận **

Toán học: các định lý cốt lõi (injectivity, CSG correctness, rotation by mask-add under guard-safe) có chứng minh toán học đơn giản và chặt chẽ; scaling bằng mã hoá log là đúng tính chất toán học (log turn multiplication into addition modulo quantization error). Những bằng chứng này đã được trình bày rõ ràng ở trên.

Kỹ thuật/kiến trúc: LIGA đưa ra một cách thiết kế kiến trúc (UWR/MPU) có thể xây dựng bằng các kỹ thuật hardware hiện nay (chunking, BRAM/URAM, carry-isolation, ECC). Tôi đã cung cấp phương pháp triển khai cụ thể (module breakdown, mapping steps, ước lượng công thức) và lộ trình prototype FPGA để kiểm chứng. Điều này là constructive: tức một kỹ sư có thể làm theo để thực hiện prototype.

Phạm vi đột phá: LIGA là tiềm năng đột phá cho bài toán rời rạc n-chiều trong trường hợp các yếu tố đầu vào phù hợp (discrete grid, mass uniform operations, topology-centred). Việc khẳng định LIGA là đột phá tổng quát trong mọi ngữ cảnh là quá rộng và đòi hỏi thí nghiệm rộng rãi; tôi đã cung cấp lộ trình để kiểm chứng điều đó.


**19. Tài liệu tham khảo & bước tiếp theo (ngắn gọn)**

Bước tiếp theo thực nghiệm: triển khai phần mềm tham chiếu (bắt đầu từ mã Python mẫu), sau đó FPGA prototype; chạy benchmark so sánh với vectorized CPU và GPU cho bộ test đã nêu.

**Phần đính kèm ngắn (Appendix: các mệnh đề đã chứng minh tóm tắt)**

Định lý 2.1 (Injectivity) — chứng minh dựa trên ánh xạ bit-positions.

Định lý 3.1 (CSG correctness) — chứng minh bằng mapping bit ↔ occupancy.

Định lý 5.1 (Rotation bằng mask-add) — chứng minh bằng phân tích carry và isolation guard.

Định lý 6.1 (Scaling via log) — chứng minh từ tính chất log.

Định lý 7.1 (Reversibility with ECC) — luận lý: ECC sửa lỗi ≤ t ⇒ phép nghịch đảo có thể thực hiện.

