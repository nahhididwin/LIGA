# LIGA — Linearized Integer Geometry Architecture

Github : https://github.com/nahhididwin/LIGA/

**Kiến trúc hình học số nguyên tuyến tính**


# Tóm tắt (Abstract)



LIGA (Linearized Integer Geometry Architecture) là một khuôn lý thuyết + kiến trúc nhằm mã hoá mọi thực thể hình học rời rạc hữu hạn (tile, voxel, octree node, v.v.) vào một số nguyên lớn duy nhất
$$\mathbb{L}$$ theo quy ước PFE (Polar Frame Encoding). Bằng cách thiết kế layout bit với các phân đoạn độc lập (Guard, State, Radius, Phase), ta có thể diễn đạt các phép biến đổi hình thái (Boolean/CSG, translation, rotation rời rạc, scaling via log-encoding) dưới dạng các thao tác số nguyên nguyên thủy (shift, bitwise, add modulo theo phân đoạn) và đưa ra điều kiện cần-đủ để những phép toán đó tương đương chính xác với phép toán hình học mong muốn.


Trong văn bản này tôi:

1. Định nghĩa chính xác không gian, ánh xạ $$\mathcal{F}$$ và PFE (độ dài, offset các phân đoạn).

2. Phát biểu và chứng minh các định lý: injectivity, tính đúng đắn CSG, điều kiện không-carry (guard-safe) và tính đúng đắn của rotation bằng mask-add, tính chất scaling qua mã hoá log, tính đảo ngược (reversibility) có điều kiện khi dùng ECC.

3. Mô tả mô hình lỗi và các cơ chế giảm lỗi (guard, ECC, RNS, dithering) với chỉ dẫn rõ ràng để lựa chọn tham số sao cho các điều kiện chứng minh thỏa.

4. Trình bày phương pháp xây dựng UWR (Ultra-Wide Register) và MPU (Morphological Processing Unit) một cách xây dựng: cách tổ chức thanh ghi rất rộng bằng các phần tử phần cứng hiện có (block RAM, LUT, DSP, multi-word buses), mảng cộng song song phân đoạn, barrel shifter matrix, và mapping thực tế lên FPGA như một prototype khả thi (các bước, thuật toán, ước lượng tài nguyên biểu thức).

5. Đưa ra lộ trình thí nghiệm chi tiết kèm tập dữ liệu, kiểm định điều kiện lý thuyết, inject-fault tests, và phép so sánh đối chứng (GPU, vectorized CPU).

6. Trình bày các kịch bản ứng dụng, hạn chế, trade-offs, và các bằng chứng luận lý cho mọi khẳng định.

Kết luận: LIGA có tiềm năng trở thành một lối tiếp cận mạnh cho các bài toán hình thái rời rạc n-chiều, khi và chỉ khi (i) đối tượng bài toán thỏa 3 điều kiện đã nêu (rời rạc, biến đổi đồng loạt, chú trọng topology), và (ii) kiến trúc UWR/MPU được triển khai sao cho thỏa các điều kiện guard/ECC/RNS. Tôi cung cấp đủ công thức, chứng minh và lộ trình để kiểm chứng thực nghiệm những tuyên bố này.



# Nội dung chi tiết

**1. Định nghĩa cơ bản, ký hiệu**

$n$ — số chiều (có thể $n \geq 1$).

Một lưới rời rạc $G$ có $d$ bit theo mỗi chiều (kích thước $2^d$ per-dimension). Tổng ô $= 2^{d \cdot n}$.

Mỗi frame: một đơn vị packing dùng để mô tả một tile/hypervoxel/ô trong cây (octree node) — chứa các trường: Phase $\phi$ (vòng pha rời rạc), Radius $\rho$, State $S$ (trạng thái vật liệu), và Guard $Gd$.

Ký hiệu $W =$ tổng số bit của một PFE; $N =$ số PFE đóng gói trong $\mathbb{L}$. Do đó $\mathbb{L} \in \{0, \dots, 2^{NW} - 1\}$ và

$$\mathbb{L} = \sum_{k=0}^{N-1} \text{PFE}_k \cdot 2^{kW}.$$

Mỗi PFE có phân đoạn bit (từ LSB $\to$ MSB): $\phi$ (width $\varphi$), $\rho$ (width $r$), $S$ (width $s$), $Gd$ (width $g$), với $g + s + r + \varphi = W$.

Offset of $\phi$ in PFE: $o_\phi$ (LSB position).

Trong phần sau, khi viết "thêm $v$ vào phân đoạn $\phi$", tôi hiểu đó là thêm theo modulo $2^\varphi$ và thực hiện bằng một phép cộng toàn chuỗi trên $\mathbb{L}$ với một mặt nạ $M(v)$ đã được định nghĩa.

**2. Ánh xạ $\mathcal{F}$ và tính injective**

Định nghĩa 2.1 (Packing $\mathcal{F}$). Với một bộ frame $F = \{\text{PFE}_0, \dots, \text{PFE}_{N-1}\}$, định nghĩa $\mathcal{F}(F) = \sum_{k=0}^{N-1} \text{PFE}_k \cdot 2^{kW}$.

Định lý 2.1 (Injectivity). Cho hai cấu trúc occupancy $A, B$ trên cùng grid/pacing và cùng quy ước packing. Nếu tồn tại ít nhất một ô $i$ sao cho $o_A(i) \neq o_B(i)$ thì $\mathcal{F}(A) \neq \mathcal{F}(B)$.

Chứng minh. Vì quy ước packing cố định ánh một ô cụ thể tới một bit cụ thể trong một PFE cố định, khác biệt occupancy tại ô $i$ làm thay đổi bit tương ứng trong PFE tương ứng. Do phép đóng gói là phép ánh xạ tuyến tính trên bit-positions (với cơ số 2) nên hai biểu diễn phải khác nhau. $\square$

Đây là bằng chứng đơn giản nhưng quan trọng: injectivity phụ thuộc vào quy ước packing không đổi. Nếu packing thay đổi giữa hai biểu diễn thì injectivity không còn đảm bảo — điều này phải được cảnh báo trong thực nghiệm.

**3. CSG và tính chính xác**

Định lý 3.1 (CSG chính xác bằng bitwise logic). Với quy ước packing 1-bit per cell (mỗi ô tương ứng một bit occupancy), các phép toán tập rời rạc chuẩn (union/intersection/difference) tương đương đúng đắn với các phép toán bitwise trên $\mathbb{L}$:

$$\mathbb{L}_{A \cap B} = \mathbb{L}_A \ \& \ \mathbb{L}_B, \quad \mathbb{L}_{A \cup B} = \mathbb{L}_A \ | \ \mathbb{L}_B, \quad \mathbb{L}_{A \setminus B} = \mathbb{L}_A \ \& \ \neg \mathbb{L}_B.$$

Chứng minh. Mỗi bit là chỉ thị occupancy, và các phép toán tập Boolean tương ứng bit-wise. Do đó trên không gian toàn bộ bit-positions, phép toán tập tương đương phép toán logic bit. $\square$

Hệ quả thực nghiệm: cho bất kỳ cài đặt phần mềm/hardware nào thực hiện bitwise ops trên cùng ordering, các phép CSG là chính xác tuyệt đối (không tồn tại lỗi làm sai vị trí nào) — miễn là các bit không bị lỗi (bit-flip) trong quá trình.

**4. Guard-safety: điều kiện tránh carry cross-segment — chứng minh toán học**

Mục tiêu: khi ta thực hiện phép cộng mặt nạ $M(v)$ (cộng $v$ vào trường $\phi$ của mọi PFE cùng lúc bằng một phép cộng trên toàn $\mathbb{L}$), chúng ta cần đảm bảo không có carry làm thay đổi các phân đoạn khác của cùng PFE hoặc lan sang PFE bên cạnh.

**4.1 Mô tả carry chain**

Khi cộng hai số nguyên, carry có thể propagate từ bit thấp lên bit cao qua nhiều bit liên tiếp.

Nếu trong PFE ta chia thành phân đoạn liên tiếp, để cô lập phép cộng trong một phân đoạn cần đảm bảo rằng carry không vượt ra khỏi vùng dự phòng (guard).

**4.2 Điều kiện đơn giản (sufficiency)**

Định nghĩa (Guard-safe layout). Gọi $C_{\max}$ là giá trị lớn nhất có thể phát sinh ở tổng của trường $\phi$ cộng các phép cộng chồng (ví dụ nếu áp dụng tối đa $t$ lần cộng $v$ liên tiếp trước khi kiểm tra/reset), thì nếu:

$$2^\varphi (\text{modulus}) \times t \leq 2^\varphi \cdot t \leq 2^\varphi \cdot (2^g - 1)$$

hay tương đương,

$$g > \lfloor \log_2 (C_{\max} / 2^\varphi) \rfloor$$

thì guard có đủ bit để chứa mọi carry không cho phép lan sang phân đoạn tiếp theo. Cách phát biểu đầy đủ hơn:

Điều kiện (sufficient): nếu mọi phép toán cộng trên phân đoạn $\phi$ có tổng tại mỗi PFE nằm trong khoảng $[0, 2^\varphi - 1 + R]$ với $R$ là tổng carry tạm thời tối đa, và nếu $R < 2^g$ thì carry không thể đặt 1 vào bất kỳ bit nào bên ngoài trường guard (vì guard có ít nhất $g$ bit đặt để nhận carry). Do đó vùng State/Radius/next-PFE không bị ảnh hưởng.

**Chứng minh (phác thảo "carry bounding")**

Khi cộng $M(v)$ trên toàn $\mathbb{L}$, mỗi PFE nhận một cộng $v$ vào trường $\phi$. Giá trị trước addition tại PFE $k$ là $x_k \in [0, 2^\varphi - 1]$. Sau addition và modulo $2^\varphi$ nội bộ, carry ra khỏi trường $\phi$ có giá trị $c_k = \lfloor (x_k + v) / 2^\varphi \rfloor \in \{0, 1, \dots \}$. Khi tổng số phép cộng chồng tối đa (hoặc khi các phép cộng được thực hiện liên tiếp trước khi làm sạch) là $t$, tổng carry tích lũy tối đa vào vùng guard là $\leq c_{\max} t$ với $c_{\max} \leq \lceil v / 2^\varphi \rceil$. Nên nếu guard có thể biểu diễn mọi giá trị carry tích lũy (tức $2^g - 1 \geq$ tổng carry), carry sẽ bị chứa trong guard và không làm bốc bit ở phân đoạn kế tiếp. Vì vậy guard-safety đảm bảo isolation. $\square$

Lưu ý thực tế: công thức chính xác của $C_{\max}$ phụ thuộc chiến lược thực hiện (single global addition với modulo $2^{NW}$ hay successive small adds) — trong thực nghiệm bạn phải tính $t$ và $v$ cụ thể.

**4.3 Điều kiện cần thiết**

Nếu guard quá nhỏ để chứa carry tích lũy, tồn tại bộ khởi tạo PFE sao cho carry sẽ lan sang phân đoạn bên cạnh và thay đổi state/ radius; do đó guard-safety là cần nếu bạn muốn không có thay đổi cross-segment trong mọi trường hợp. Tuy nhiên, nếu bạn có kiểm soát ngặt việc thực hiện phép cộng (ví dụ chỉ thực hiện khi biết $x_k + v < 2^g$ cho mọi $k$) thì guard có thể nhỏ hơn; đó là trade-off.

**5. Rotation bằng mask-add: định lý và chứng minh chặt chẽ**

Định nghĩa (Phase mask). Với một giá trị pha rời rạc $v \in [0, 2^{\varphi} - 1]$, định nghĩa

$$M(v) = \sum_{k=0}^{N-1} v \cdot 2^{kW+o_{\phi}}.$$

(Đây là số nguyên có cùng trường $\phi$ của mỗi PFE đặt bằng $v$.)

Định lý 5.1 (Rotation bằng addition toàn cục). Nếu layout là guard-safe theo định nghĩa ở trên và phép toán được thực hiện bằng một phép cộng toàn cục

$$\mathbb{L}' = (\mathbb{L} + M(v)) \bmod 2^{NW},$$

thì với mỗi PFE $k$, trường $\phi$ của $\text{PFE}_k$ được cập nhật đúng bằng

$$\phi'_k = (\phi_k + v) \bmod 2^{\varphi},$$

và các phân đoạn khác (state, rho, guard) không thay đổi (ngoại trừ phần guard chứa carry). Nghĩa là phép toán tương đương với "xoay rời rạc" mọi frame cùng lúc.

Chứng minh.

Viết $\mathbb{L} = \sum_k p_k 2^{kW}$ với $p_k \in [0, 2^W - 1]$ là mỗi PFE dưới dạng integer. Mặt nạ $M(v)$ viết được dưới dạng $\sum_k v 2^{kW+o_{\phi}}$.

Ở mỗi PFE, addition $p_k + v \cdot 2^{o_{\phi}}$ chỉ tác động lên các bit trong dải $[o_{\phi}, o_{\phi} + \varphi - 1]$ và có thể tạo carry sang các bit trên (vùng guard nằm bên trên). Nếu guard-safety đảm bảo carry sẽ dừng trong guard và không tạo carry sang phân đoạn state/rho của cùng PFE, thì phần state/rho giữ nguyên.

Do phép cộng cộng đồng (global integer add) tương đương nối các phép cộng độc lập tại từng PFE kèm propagate carry giữa PFE $k$ và $k+1$ chỉ khi overflow qua $W$-bits xuất hiện. Nếu ta thực hiện modulo $2^{NW}$ và bố cục PFE liên tiếp, overflow từ PFE $k$ sang PFE $k+1$ sẽ chỉ xảy ra nếu total carry vào bit $kW + W$ là $\ge 1$. Nhưng với guard đủ dài để chặn mọi carry đã giới hạn, overflow không xảy ra.

Kết luận: mỗi $\phi_k$ được cộng modulo $2^{\varphi}$ độc lập. $\Box$

**6. Scaling bằng mã hoá log (chứng minh toán học)**

Định lý 6.1 (Scaling $\approx$ addition trên mã hóa log). Giả sử bạn mã hoá bán kính bằng một số nguyên rời rạc $\tilde{\rho} = \text{enc}(\ln \rho)$ sao cho $\text{dec}(\tilde{\rho})$ là một hàm xấp xỉ $\exp$ của $\tilde{\rho}$. Khi đó nhân bán kính bởi konst $s > 0$ tương đương cộng hằng số vào $\tilde{\rho}$:

$$\text{enc}(\ln(s\rho)) = \text{enc}(\ln s + \ln \rho) \approx \text{enc}(\ln s) + \tilde{\rho},$$

với sai số $\le$ nửa bước mã hóa (quantization error).

Chứng minh (lôg-linearity). Trivial từ log: $\ln(s\rho) = \ln s + \ln \rho$. Nếu $\text{enc}$ là một ánh xạ tuyến tính (hoặc tuyến tính từng đoạn) từ $\ln(\cdot)$ về số nguyên, thì phép nhân biến thành phép cộng với sai số do rời rạc hoá. Độ lớn sai số có thể phân tích: nếu $\text{enc}$ là $\tilde{\rho} = \lfloor \alpha \ln \rho + \beta \rceil$ thì sai số $\le 1/2$ (đơn vị mã hóa). $\square$

Lưu ý: điều này chỉ hữu dụng khi ứng dụng chấp nhận sai số multiplicative nhỏ do rời rạc hoá — phù hợp với các bài toán topology/occupancy, không phù hợp khi cần metric chính xác.

**7. Reversibility có điều kiện qua ECC (chứng minh)**



Định nghĩa (ECC block). Mỗi PFE mang thêm một trường guard chứa mã sửa lỗi block-code (ví dụ BCH hoặc LDPC) có độ dài $g$ bit, mã có khoảng cách Hamming $d_{\min}$, sửa được $t = \lfloor (d_{\min} - 1)/2 \rfloor$ lỗi trong block đó.

Định lý 7.1 (Reversibility có điều kiện). Cho một chuỗi phép toán $T$ từ $\mathbb{L}_0$ đến $\mathbb{L}_f$ gồm các thao tác bitwise, shift, add-modulo cục bộ thỏa guard-safe; nếu trong suốt chuỗi này, số bit lỗi không kiểm soát trong mỗi block $\le t$ tại mọi thời điểm trước khi đảo ngược, thì ta có thể phục hồi trạng thái ban đầu bằng cách: (i) dùng ECC để sửa lỗi ở mỗi bước hoặc (ii) sửa lỗi sau khi hoàn tất chuỗi, rồi áp dụng các phép toán nghịch đảo tuần tự.

Chứng minh (ý chính). Các phép toán bitwise/shift/add (khi guard-safe) là ánh xạ toàn đồ (bijective) trên không gian giá trị hợp lệ (tức không có lỗi trong bit payload), hoặc ít nhất là injective nếu ta biết lịch sử thao tác. Nếu $\text{errors} \le t$ trong mỗi block, ECC sẽ khôi phục block về giá trị hợp lệ (nhãn trước biến đổi). Do đó sau khi sửa lỗi, ta có thể áp dụng phép nghịch đảo toán học (subtraction modulo, shift ngược, bitwise inverse) để phục hồi $\mathbb{L}_0$. $\square$

Thực nghiệm: đảm bảo điều kiện "$\text{errors} \le t$ tại mọi thời điểm" là nhiệm vụ của cơ chế phát hiện/giới hạn lỗi — ví dụ bằng redundancy, parity checks thường xuyên, hoặc cơ chế rollback checkpoints.

**8. RNS (Residue Number System) và tính tránh carry — lời giải toán học + thực hành**

8.1 Lý thuyết RNS ngắn

Chọn moduli $m_1, \dots, m_k$ pairwise coprime, tổng miền biểu diễn tới sản phẩm $M = \prod_{i} m_i$.

Một số $X$ được biểu diễn qua residues $(x_1, \dots, x_k)$ với $x_i = X \pmod{m_i}$.

Các phép cộng/trừ trong RNS thực hiện độc lập trên từng modulus — không có carry giữa residues $\to$ phù hợp cho add throughput cao.

Ưu-nhược: RNS cho phép cộng nhanh, không carry, nhưng phép so sánh/scale/CRC cần chuyển đổi CRT (Chinese Remainder) hoặc các thuật toán so sánh RNS phức tạp.

8.2 Ứng dụng trong LIGA

Đối với trường radius hoặc các trường cần dynamic range lớn nhưng ít phép so sánh, lưu theo RNS bên trong PFE (chia thành nhiều sub-fields được hiểu là residues) giúp tránh carry chain khi cộng các offset lớn. Việc encode/decode RNS cần routines CRT/GA, tôi cung cấp thuật toán chuyển đổi nhanh (Garner's algorithm) và ước lượng độ phức tạp $O(k^2)$ naive hoặc $O(k \log^2 M)$ nếu dùng FFT-based modular multiplications.

Hướng dẫn thực hiện: trong thiết kế hardware, mỗi modulus có thể được xử lý bằng mảng adder nhỏ độc lập; lưu trữ residues trong vùng lưu trữ phân đoạn và sửa lỗi độc lập.

**9. Mô hình lỗi, ECC chi tiết & chiến lược chọn tham số (hướng dẫn thực hiện)**

9.1 Mô tả nguồn lỗi

Soft errors (bit flips): tỷ lệ lỗi $p$ per bit/time.

Hard errors (permanent stuck bits): cần detect + retire.

Arithmetic overflow/carry (do guard thiếu): dẫn đến corruption lớn.

Quantization error (rời rạc hóa encoding): là sai số chấp nhận được trong topology tasks.

9.2 Lựa chọn ECC

Nếu mục tiêu: bảo vệ chống $\le t$ lỗi per-PFE giữa 2 checkpoints, chọn BCH/RS hoặc LDPC với thông số $(n, k, t)$.

Thiết kế tham số:

Dự trữ $g$ bits guard = ECC parity bits + slack bits để cô lập carry.

Chọn $t$ dựa trên $p$ (tỷ lệ lỗi), chu kỳ giữa các checks $T_c$, và số bit per block $n$: đảm bảo $P(> t \text{ lỗi}) \ll \epsilon$ theo yêu cầu tin cậy. (Xác suất có thể ước lượng bằng phân phối binomial hoặc Poisson.)


Thực hiện: sử dụng BCH cho block size $\le$ few Kbits, hoặc LDPC cho block lớn với decoder sum-product trong hardware.

9.3 Dithering / oversampling bit-domain

Khi rời rạc hóa góc/phases gây aliasing, thực hiện oversampling internal: lưu oversampled phase (ví dụ nhiều sub-phase) và trộn bit error bằng bit-shuffle $\rightarrow$ hiệu ứng tương tự noise trắng. Sau đó lọc (về phép phi tuyến học) làm mượt artifacts. Đây là phương pháp engineering để giảm artifacts rời rạc.

**10. Kiến trúc MPU và cách xây dựng UWR — hướng dẫn kỹ thuật đầy đủ (constructive)**


