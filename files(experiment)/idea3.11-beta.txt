# LIGA â€” Linearized Integer Geometry Architecture

**Kiáº¿n trÃºc hÃ¬nh há»c sá»‘ nguyÃªn tuyáº¿n tÃ­nh**

Github : https://github.com/nahhididwin/LIGA/

---

## TÃ³m táº¯t (Abstract)

LIGA (Linearized Integer Geometry Architecture) lÃ  má»™t khuÃ´n toÃ¡n há»c-kiáº¿n trÃºc nháº±m biá»ƒu diá»…n, biáº¿n Ä‘á»•i vÃ  xá»­ lÃ½ cÃ¡c Ä‘á»‘i tÆ°á»£ng hÃ¬nh há»c rá»i ráº¡c há»¯u háº¡n báº±ng má»™t **sá»‘ nguyÃªn cÃ³ cáº¥u trÃºc** duy nháº¥t kÃ½ hiá»‡u (\mathbb{L}). Má»—i thá»±c thá»ƒ Ä‘Æ°á»£c phÃ¢n máº£nh thÃ nh cÃ¡c Polar Frame Encoding (PFE), trong Ä‘Ã³ má»—i PFE cÃ³ cÃ¡c phÃ¢n Ä‘oáº¡n bit Ä‘á»™c láº­p cho bÃ¡n kÃ­nh (\rho), pha/gÃ³c (\phi), tráº¡ng thÃ¡i váº­t liá»‡u (S) vÃ  vÃ¹ng báº£o vá»‡ (Guard/ECC). CÃ¡c phÃ©p biáº¿n Ä‘á»•i hÃ¬nh há»c há»¯u Ã­ch â€” dá»‹ch, xoay, tá»‰ lá»‡, phÃ©p toÃ¡n táº­p (CSG), chiáº¿u â€” Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng cÃ¡c thao tÃ¡c sá»‘ nguyÃªn nguyÃªn thá»§y (shift, add modulo trÃªn phÃ¢n Ä‘oáº¡n, AND/OR/NOT, trÃ­ch bit). TÃ i liá»‡u nÃ y Ä‘Æ°a ra cÃ¡c Ä‘á»‹nh nghÄ©a rÃµ rÃ ng, cÃ¡c Ä‘á»‹nh lÃ½ cÃ³ chá»©ng minh, mÃ´ táº£ mÃ´ hÃ¬nh lá»—i, cÆ¡ cháº¿ cÃ¡ch ly vÃ  sá»­a lá»—i (Guard, RNS, ECC), kiáº¿n trÃºc pháº§n cá»©ng Ä‘á» xuáº¥t (MPU â€” Morphological Processing Unit), vÃ  lá»™ trÃ¬nh thÃ­ nghiá»‡m Ä‘á»ƒ chá»©ng minh tÃ­nh hiá»‡u quáº£ thá»±c nghiá»‡m.

Má»¥c tiÃªu : Chuyá»ƒn Ä‘á»•i cÃ¡c bÃ i toÃ¡n Ä‘áº¡i sá»‘ hÃ¬nh thÃ¡i Ä‘a chiá»u ($nD$ Morphology) â€” bao gá»“m cÃ¡c cáº¥u trÃºc occupancy/Boolean/hyper-voxel phá»©c táº¡p â€” thÃ nh toÃ¡n há»c bit-parallel cÃ³ tÃ­nh kháº£ thi pháº§n cá»©ng; Ä‘á»“ng thá»i xÃ¡c láº­p cÃ¡c há»‡ thá»©c vá» Ä‘á»™ chÃ­nh xÃ¡c, giá»›i háº¡n váº­t lÃ½ vÃ  chi phÃ­ tÃ i nguyÃªn cá»§a kiáº¿n trÃºc.



**Má»™t vÃ­ dá»¥ cho viá»‡c LIGA giáº£i bÃ i toÃ¡n n-chiá»u (nD) :**

MÃ´ táº£ váº¥n Ä‘á» nD : Giáº£ sá»­ ta cÃ³ má»™t táº­p S gá»“m N â€œtile framesâ€, má»—i tile lÃ  má»™t Ã´ occupancy trong má»™t lÆ°á»›i rá»i ráº¡c kÃ­ch thÆ°á»›c 2^d theo má»—i chiá»u (tá»©c tá»•ng cells = 2^(d.n) â€” biá»ƒu diá»…n cá»±c lá»›n khi n tÄƒng). Ta muá»‘n thá»±c hiá»‡n má»™t phÃ©p quay rá»i ráº¡c cÃ¹ng gÃ³c Î”Î¸ lÃªn táº¥t cáº£ tile frames (hoáº·c táº¥t cáº£ nodes cá»§a má»™t octree/quadtree á»Ÿ má»i vá»‹ trÃ­) Ä‘á»“ng thá»i â€” tá»©c thay Ä‘á»•i trÆ°á»ng pha ğœ‘ cá»§a má»—i frame báº±ng cÃ¹ng má»™t offset.

Vá»›i cáº¥u trÃºc PFE cá»§a LIGA, náº¿u báº¡n Ä‘Ã³ng gÃ³i N frames liÃªn tiáº¿p (má»—i frame cÃ³ phÃ¢n Ä‘oáº¡n pha ğœ‘ náº±m á»Ÿ offset cá»‘ Ä‘á»‹nh trong PFE) thÃ¬ má»™t phÃ©p cá»™ng nguyÃªn duy nháº¥t:

$$\mathbb{L}' = (\mathbb{L} + M(v)) \bmod 2^{NW}$$

vá»›i M(v) lÃ  mask-add Ä‘Ã£ Ä‘á»‹nh nghÄ©a (Ä‘áº·t giÃ¡ trá»‹ v vÃ o vá»‹ trÃ­ phÃ¢n Ä‘oáº¡n pha cá»§a má»—i frame), sáº½ xoay táº¥t cáº£ N frame cÃ¹ng lÃºc â€” tá»©c thá»±c hiá»‡n N phÃ©p xoay Ä‘á»™c láº­p chá»‰ báº±ng má»™t addition (má»™t chuá»—i bitwise add) náº¿u layout guard-safe.


LÆ°u Ã½ : LÃ½ thuyáº¿t nÃ y cho Ä‘áº¿n táº­n lÃºc Ä‘Æ°á»£c Ä‘Äƒng lÃªn váº«n chá»‰ Ä‘ang Ä‘Æ°á»£c má»™t há»c sinh sinh nÄƒm 2011 nghiÃªn cá»©u/phÃ¡t triá»ƒn. NÃ³ váº«n cÃ³ thá»ƒ cÃ³ háº¡n cháº¿, hy vá»ng sáº½ Ä‘Æ°á»£c gÃ³p Ã½ hoáº·c Ä‘Æ°á»£c cá»™ng Ä‘á»“ng giÃºp Ä‘á»¡ trong viá»‡c hoÃ n thiá»‡n.


---

## Má»¥c lá»¥c

1. Giá»›i thiá»‡u vÃ  Ä‘á»™ng cÆ¡
2. KhÃ´ng gian, Ã¡nh xáº¡ (\mathcal{F}) vÃ  tÃ­nh cháº¥t cÆ¡ báº£n
3. Cáº¥u trÃºc PFE vÃ  quy táº¯c Guard (layout bit)
4. ToÃ¡n tá»­ hÃ¬nh thÃ¡i: Ä‘á»‹nh nghÄ©a, luÃ´n Ä‘Ãºng vÃ  Ä‘iá»u kiá»‡n
5. Äá»‹nh lÃ½ chÃ­nh vÃ  chá»©ng minh
6. MÃ´ hÃ¬nh lá»—i vÃ  há»‡ giáº£m sai sá»‘ (RNS, ECC, Dithering)
7. Kiáº¿n trÃºc MPU: pháº§n cá»©ng vÃ  ISA
8. PhÃ¢n tÃ­ch Ä‘á»™ phá»©c táº¡p & bÄƒng thÃ´ng
9. Giao diá»‡n rendering: Bitâ†’Pixel vÃ  Neural Bit-Decoder
10. Háº¡n cháº¿, rá»§i ro vÃ  pháº¡m vi á»©ng dá»¥ng
11. Káº¿ hoáº¡ch thÃ­ nghiá»‡m vÃ  benchmark chi tiáº¿t
12. Káº¿t luáº­n vÃ  hÆ°á»›ng phÃ¡t triá»ƒn

Appendix A: Pseudocode cÆ¡ báº£n
Appendix B: VÃ­ dá»¥ numeric minh hoáº¡ carry/guard
Appendix C: Tháº£o luáº­n vá» trade-offs

---

## 1. Giá»›i thiá»‡u vÃ  Ä‘á»™ng cÆ¡

CÃ¡c há»‡ thá»‘ng Ä‘á»“ hoáº¡ truyá»n thá»‘ng chá»§ yáº¿u dÃ¹ng biá»ƒu diá»…n liÃªn tá»¥c (tá»a Ä‘á»™ thá»±c, ma tráº­n, phÃ©p toÃ¡n FP) cho rendering, mÃ´ phá»ng vÃ  collision. Tuy nhiÃªn nhiá»u váº¥n Ä‘á» thá»±c táº¿ â€” CSG (constructive solid geometry), boolean trÃªn voxel, spatial indexing, collision detection â€” chá»§ yáº¿u liÃªn quan tá»›i **tÃ­nh occupancy** vÃ  cÃ¡c phÃ©p toÃ¡n táº­p rá»i ráº¡c. LIGA nháº¯m vÃ o lá»›p bÃ i toÃ¡n nÃ y: táº­n dá»¥ng tÃ­nh song song á»Ÿ má»©c bit Ä‘á»ƒ thá»±c hiá»‡n cÃ¡c phÃ©p toÃ¡n táº­p vÃ  biáº¿n Ä‘á»•i hÃ¬nh thÃ¡i trÃªn khÃ´ng gian rá»i ráº¡c vá»›i Ä‘á»™ trá»… tháº¥p vÃ  tÃ­nh nÄƒng sá»­a lá»—i cÃ³ tÃ­nh toÃ¡n.

Quan Ä‘iá»ƒm then chá»‘t: mÃ£ hÃ³a cáº¥u trÃºc hÃ¬nh há»c vÃ o má»™t sá»‘ nguyÃªn siÃªu-cáº¥u trÃºc (\mathbb{L}) theo quy Æ°á»›c PFE, rá»“i thá»±c hiá»‡n cÃ¡c biáº¿n Ä‘á»•i hÃ¬nh há»c lÃ  cÃ¡c thao tÃ¡c bit/aritmetic phÃ¢n Ä‘oáº¡n. TÃ i liá»‡u nÃ y xÃ¡c Ä‘á»‹nh chÃ­nh xÃ¡c khi nÃ o cÃ¡c phÃ©p toÃ¡n nÃ y lÃ  *Ä‘Ãºng vá» máº·t toÃ¡n há»c* vÃ  cung cáº¥p cÃ¡c chá»©ng minh cÃ¹ng mÃ´ hÃ¬nh lá»—i Ä‘á»ƒ xÃ¢y dá»±ng pháº§n cá»©ng tin cáº­y.

---

## 2. KhÃ´ng gian, Ã¡nh xáº¡ (\mathcal{F}) vÃ  tÃ­nh cháº¥t cÆ¡ báº£n

### 2.1 KhÃ´ng gian nguá»“n

Gá»i (\mathcal{M}\subset\mathbb{R}^n) lÃ  khÃ´ng gian metric vá»›i metric chuáº©n (Euclid). Chá»n má»™t lÆ°á»›i rá»i ráº¡c hoÃ¡ (grid) vá»›i Ä‘á»™ phÃ¢n giáº£i há»¯u háº¡n (r); táº­p Ã´ lÆ°á»›i lÃ  (I), (|I|=m). Má»™t hÃ¬nh thá»ƒ há»¯u háº¡n (\mathcal{S}\subset\mathcal{M}) Ä‘Æ°á»£c rá»i ráº¡c hoÃ¡ thÃ nh occupancy function
[ o_{\mathcal{S}}: I\to{0,1},\qquad o_{\mathcal{S}}(i)=1 \iff \text{Ã´ }i\text{ bá»‹ chiáº¿m} .]

### 2.2 Äá»‹nh nghÄ©a Ã¡nh xáº¡ (\mathcal{F})

Chá»n tham sá»‘: má»—i PFE dÃ i (W) bit; PFE gá»“m (p) phÃ¢n Ä‘oáº¡n (má»—i segment width (w) hoáº·c biáº¿n thiÃªn) â€” trong thá»±c táº¿ ta Ä‘áº·t cÃ¡c phÃ¢n Ä‘oáº¡n cÃ³ chiá»u dÃ i (g,s,r,\varphi) tÆ°Æ¡ng á»©ng Guard, State, Radius, Phase sao cho (g+s+r+\varphi=W). Má»™t Ä‘á»‘i tÆ°á»£ng Ä‘Æ°á»£c mÃ£ hoÃ¡ thÃ nh:
[
\mathcal{F}(\mathcal{S})=\mathbb{L}=\sum_{k=0}^{N-1} \mathrm{PFE}_k\cdot 2^{kW},
]
trong Ä‘Ã³ má»—i (\mathrm{PFE}_k\in{0,\dots,2^W-1}) chá»©a thÃ´ng tin vá» má»™t frame (má»™t tile, octree node, hoáº·c Ã´)

**LÆ°u Ã½:** Ã¡nh xáº¡ phá»¥ thuá»™c vÃ o quy Æ°á»›c tileization/paking; tÃ­nh toÃ¡n vÃ  chá»©ng minh trong giáº¥y nÃ y Ä‘á»u giáº£ sá»­ cÃ¹ng grid/packing.

### 2.3 TÃ­nh injective trÃªn cÃ¹ng packing

**Äá»‹nh lÃ½ 2.1 (Injectivity trÃªn cÃ¹ng parity/packing).** Náº¿u (\mathcal{S}_1) vÃ  (\mathcal{S}_2) cÃ³ cÃ¡c occupancy khÃ¡c nhau táº¡i Ã­t nháº¥t má»™t Ã´ (i\in I), thÃ¬ (\mathcal{F}(\mathcal{S}_1)\neq\mathcal{F}(\mathcal{S}_2)).

**Chá»©ng minh.** Má»—i Ã´ tÆ°Æ¡ng á»©ng vá»›i má»™t vá»‹ trÃ­ bit cá»‘ Ä‘á»‹nh trong cáº¥u trÃºc cÃ¡c PFE; khÃ¡c biá»‡t occupancy á»Ÿ Ã´ (i) gÃ¢y khÃ¡c biá»‡t á»Ÿ Ã­t nháº¥t má»™t bit trong (\mathbb{L}). Do Ä‘Ã³ hai sá»‘ khÃ¡c nhau. â–¡

---

## 3. Cáº¥u trÃºc PFE vÃ  quy táº¯c Guard (layout bit)

### 3.1 YÃªu cáº§u thiáº¿t káº¿

Má»¥c tiÃªu layout:

1. TÃ¡ch biá»‡t cÃ¡c phÃ¢n Ä‘oáº¡n sao cho phÃ©p cá»™ng trÃªn phÃ¢n Ä‘oáº¡n (add modulo) khÃ´ng gÃ¢y carry sang phÃ¢n Ä‘oáº¡n khÃ¡c.
2. Dá»± phÃ²ng vÃ¹ng Guard chá»©a ECC/parity vÃ  padding Ä‘á»ƒ vÃ´ hiá»‡u hoÃ¡ carry.
3. Há»— trá»£ thao tÃ¡c song song trÃªn toÃ n bá»™ PFE báº±ng máº·t náº¡ (masks) hoáº·c broadcast.

### 3.2 Cáº¥u trÃºc máº«u

Má»—i PFE (W bits) theo thá»© tá»± caoâ†’tháº¥p: [Guard (g bits)] [State s bits] [Radius r bits] [Phase (\varphi) bits] (MSB ... LSB). Quy táº¯c: Ä‘áº·t (g) Ä‘á»§ lá»›n Ä‘á»ƒ báº¥t ká»³ phÃ©p cá»™ng trÃªn nhÃ³m (\varphi) hay (r) khÃ´ng thá»ƒ gÃ¢y carry sang trÆ°á»ng liá»n ká».

**Äá»‹nh nghÄ©a (Guard-safety).** Má»™t layout lÃ  guard-safe náº¿u má»i phÃ©p cá»™ng cá»¥c bá»™ trÃªn má»™t phÃ¢n Ä‘oáº¡n vá»›i toÃ¡n tá»­ cá»§a há»‡ (vÃ­ dá»¥ thÃªm máº·t náº¡ pha cÃ³ Ä‘á»™ lá»›n â‰¤ (2^{\varphi}-1)) khÃ´ng lÃ m báº­t bit á»Ÿ phÃ¢n Ä‘oáº¡n káº¿ cáº­n (carry).

Ta cÃ³ Ä‘iá»u kiá»‡n Ä‘Æ¡n giáº£n:
[g\ge 1\quad\text{vÃ }\quad \text{vá»›i sá»‘ phÃ©p cá»™ng chá»“ng tá»‘i Ä‘a }C,\quad g>\lfloor\log_2 C\rfloor.]
Gá»‘c thá»±c táº¿ phá»©c táº¡p hÆ¡n (xÃ©t overflow chuá»—i phÃ©p), nhÆ°ng Ä‘iá»u kiá»‡n nÃ y nÃªu rÃµ Ã½ tÆ°á»Ÿng: Ä‘áº·t dÆ° bit Ä‘á»§ lá»›n.

---

## 4. ToÃ¡n tá»­ hÃ¬nh thÃ¡i: Ä‘á»‹nh nghÄ©a, phÃ©p thá»±c thi vÃ  Ä‘iá»u kiá»‡n Ä‘Ãºng

CÃ¡c phÃ©p cÆ¡ báº£n:

* **CSG (Union/Intersection/Difference):** bitwise OR/AND/AND-NOT.
* **Translation (dá»‹ch):** shift cá»§a trÆ°á»ng occupancy theo offset Ã´; vá»›i hierarchical frame dÃ¹ng translation cá»§a frame gá»‘c.
* **Rotation (xoay):** cá»™ng modulo trÃªn trÆ°á»ng pha (\phi) báº±ng máº·t náº¡ (mask add) â€” Ä‘iá»u kiá»‡n khÃ´ng carry.
* **Scaling:** mÃ£ hÃ³a bÃ¡n kÃ­nh theo log ((\tilde\rho=\lfloor\alpha\ln\rho\rfloor)) Ä‘á»ƒ scaling trá»Ÿ thÃ nh phÃ©p cá»™ng.

Má»—i phÃ©p cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng tá»• há»£p cÃ¡c thao tÃ¡c nguyÃªn thá»§y: SHIFTs (dá»‹ch Ã´), ADD modulo trÃªn phÃ¢n Ä‘oáº¡n, AND/OR/NOT.

---

## 5. Äá»‹nh lÃ½ chÃ­nh vÃ  chá»©ng minh

### 5.1 CSG: Ä‘Ãºng Ä‘áº¯n tuyá»‡t Ä‘á»‘i

**Äá»‹nh lÃ½ 5.1 (CSG Ä‘Ãºng Ä‘áº¯n).** Náº¿u hai biá»ƒu diá»…n (\mathbb{L}_A,\mathbb{L}*B) sá»­ dá»¥ng cÃ¹ng quy Æ°á»›c packing (má»™t bit tÆ°Æ¡ng á»©ng má»—i Ã´ thÃ nh pháº§n), thÃ¬
\begin{align*}
\mathbb{L}*{A\cap B} &= \mathbb{L}_A;&;\mathbb{L}*B,\
\mathbb{L}*{A\cup B} &= \mathbb{L}_A;|;\mathbb{L}*B,\
\mathbb{L}*{A\setminus B} &= \mathbb{L}_A;&;\sim\mathbb{L}_B.
\end{align*}

**Chá»©ng minh.** TÃ­nh occupancy Ä‘Æ°á»£c Ã¡nh xáº¡ bit-1 â†” Ã´ chiáº¿m, bit-0 â†” Ã´ rá»—ng. ToÃ¡n tá»­ logic Boolean trÃªn bit tÆ°Æ¡ng á»©ng tÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i phÃ©p toÃ¡n táº­p trÃªn cÃ¡c Ã´. â–¡

### 5.2 Rotation báº±ng mask-add: Ä‘iá»u kiá»‡n cáº§n vÃ  Ä‘á»§ (cÆ¡ báº£n)

**Äá»‹nh nghÄ©a 5.1 (Phase mask).** Gá»i (o_\phi) offset bit cá»§a phÃ¢n Ä‘oáº¡n (\phi) bÃªn trong má»—i PFE. Vá»›i má»™t gÃ³c rá»i ráº¡c hoÃ¡ (\Delta\theta) biá»ƒu diá»…n bá»Ÿi (v\in{0,\dots,2^{\varphi}-1}), Ä‘á»‹nh nghÄ©a
[ M(v) = \sum_{k=0}^{N-1} v\cdot 2^{kW+o_\phi}.]

**Äá»‹nh lÃ½ 5.2 (Rotation báº±ng addition modulo trÃªn phÃ¢n Ä‘oáº¡n).** Náº¿u layout lÃ  guard-safe vÃ  má»i phÃ©p cá»™ng trÃªn phÃ¢n Ä‘oáº¡n (\phi) thá»±c hiá»‡n modulo (2^{\varphi}) mÃ  khÃ´ng cÃ³ carry vÃ o phÃ¢n Ä‘oáº¡n khÃ¡c, thÃ¬ phÃ©p
[ \mathbb{L}' = (\mathbb{L}+M(v))\bmod 2^{NW} ]
khi xÃ©t tá»«ng PFE Ä‘á»™c láº­p tÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i viá»‡c cá»™ng gÃ³c (v) modulo (2^{\varphi}) vÃ o phÃ¢n Ä‘oáº¡n pha cá»§a má»—i frame â€” tá»©c xoay rá»i ráº¡c cá»§a má»—i frame theo bÆ°á»›c gÃ³c (2\pi/2^{\varphi}).

**Chá»©ng minh.** Vá»›i guard-safe, addition cá»§a (v) chá»‰ áº£nh hÆ°á»Ÿng bits trong khoáº£ng [offset (o_\phi), offset+(\varphi-1)] trong tá»«ng PFE; pháº§n cÃ²n láº¡i khÃ´ng Ä‘á»•i. VÃ¬ váº­y má»—i phÃ¢n Ä‘oáº¡n pha Ä‘Æ°á»£c cá»™ng modulo (2^{\varphi}) Ä‘á»™c láº­p, tÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i xoay. â–¡

**Ghi chÃº:** Äiá»u kiá»‡n guard-safe lÃ  cáº§n thiáº¿t Ä‘á»ƒ Ä‘áº£m báº£o khÃ´ng chá»‹u tÆ°Æ¡ng tÃ¡c cross-segment; náº¿u cÃ³ thá»ƒ chá»©ng minh ráº±ng carry khÃ´ng thá»ƒ xáº£y ra trong pháº¡m vi phÃ©p toÃ¡n Ä‘Æ°á»£c Ã¡p dá»¥ng, thÃ¬ Ä‘á»‹nh lÃ½ Ã¡p dá»¥ng.

### 5.3 Scaling dÆ°á»›i mÃ£ hÃ³a log: phÃ©p cá»™ng trÃªn (\tilde\rho)

**Äá»‹nh lÃ½ 5.3 (Scaling báº±ng addition trÃªn log-radius).** Giáº£ sá»­ bÃ¡n kÃ­nh Ä‘Æ°á»£c lÆ°u báº±ng mÃ£ hÃ³a log rá»i ráº¡c (\tilde\rho=\mathrm{enc}(\ln\rho)) tuyáº¿n tÃ­nh so vá»›i (\ln\rho). Viá»‡c nhÃ¢n bÃ¡n kÃ­nh bá»Ÿi (s>0) tÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i cá»™ng háº±ng sá»‘ (\mathrm{enc}(\ln s)) vÃ o (\tilde\rho) (vá»›i sai sá»‘ do rá»i ráº¡c hoÃ¡ Ä‘Æ°á»£c kiá»ƒm soÃ¡t).

**Chá»©ng minh.** Tá»« tÃ­nh cháº¥t log: (\ln(s\rho)=\ln s+\ln\rho). VÃ¬ (\tilde\rho) Ä‘áº¡i diá»‡n xáº¥p xá»‰ tuyáº¿n tÃ­nh cá»§a (\ln\rho), phÃ©p nhÃ¢n trá»Ÿ thÃ nh phÃ©p cá»™ng (vá»›i sai sá»‘ rá»i ráº¡c (\le) ná»­a bÆ°á»›c mÃ£ hÃ³a). â–¡

### 5.4 Reversibility & ECC: Ä‘iá»u kiá»‡n Ä‘á»§

**Äá»‹nh nghÄ©a (ECC block).** Má»—i PFE chá»©a má»™t trÆ°á»ng Guard dÃ¹ng ECC (kÃ­ hiá»‡u mÃ£ cÃ³ khoáº£ng cÃ¡ch Hamming (d_{min})). Kháº£ nÄƒng sá»­a lá»—i lÃ  (t=\lfloor(d_{min}-1)/2\rfloor).

**Äá»‹nh lÃ½ 5.4 (Äiá»u kiá»‡n Ä‘á»§ cho reversibility cá»§a chuá»—i phÃ©p biáº¿n Ä‘á»•i).** Cho má»™t chuá»—i biáº¿n Ä‘á»•i (T) Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng cÃ¡c phÃ©p toÃ¡n bitwise, shift vÃ  add modulo trong cÃ¡c phÃ¢n Ä‘oáº¡n, náº¿u:

1. TrÆ°á»›c vÃ  sau má»i bÆ°á»›c, sá»‘ bit lá»—i (uncontrolled flips) trong má»—i khá»‘i ECC â‰¤ (t);
2. Má»i phÃ©p cá»™ng phÃ¢n Ä‘oáº¡n tuÃ¢n thá»§ guard-safe (khÃ´ng carry qua guard);

thÃ¬ ta cÃ³ thá»ƒ phá»¥c há»“i tráº¡ng thÃ¡i Ä‘áº§u tiÃªn (reversible) báº±ng cÃ¡ch dÃ¹ng dá»¯ liá»‡u ECC Ä‘á»ƒ sá»­a lá»—i vÃ  Ä‘áº£o ngÆ°á»£c cÃ¡c phÃ©p toÃ¡n Ä‘á»‡ quy (biáº¿n Ä‘á»•i lÃ  injective khi xÃ©t tá»›i lá»—i Ä‘Æ°á»£c sá»­a).

**Chá»©ng minh (phÃ¡c tháº£o).** Bá»Ÿi ECC cÃ³ thá»ƒ sá»­a â‰¤(t) lá»—i trong khá»‘i; náº¿u Ä‘iá»u kiá»‡n (1) duy trÃ¬ suá»‘t trÃ¬nh tá»±, má»i bÆ°á»›c cÃ³ thá»ƒ Ä‘Æ°á»£c sá»­a vá» giÃ¡ trá»‹ há»£p lá»‡ tÆ°Æ¡ng á»©ng. VÃ¬ cÃ¡c phÃ©p toÃ¡n bitwise vÃ  add modulo (vá»›i guard-safe) lÃ  cÃ¡c Ã¡nh xáº¡ toÃ n Ä‘á»“ phá»¥ (injective trong miá»n khÃ´ng cÃ³ lá»—i) khi biáº¿t lá»‹ch sá»­ thao tÃ¡c, ta cÃ³ thá»ƒ Ä‘áº£o ngÆ°á»£c báº±ng cÃ¡ch thá»±c hiá»‡n phÃ©p toÃ¡n nghá»‹ch Ä‘áº£o (tá»©c AND/OR nghá»‹ch, subtract modulo, shift ngÆ°á»£c). Do Ä‘Ã³ chuá»—i biáº¿n Ä‘á»•i cÃ³ thá»ƒ Ä‘áº£o ngÆ°á»£c modulo sá»­a lá»—i ECC. â–¡

**BÃ¬nh luáº­n:** ÄÃ¢y lÃ  Ä‘iá»u kiá»‡n *Ä‘á»§*; trong thá»±c táº¿ viá»‡c giá»¯ giá»›i háº¡n lá»—i yÃªu cáº§u thiáº¿t káº¿ ECC + guard há»£p lÃ½.

### 5.5 PhÃ¢n rÃ£ primitives (mÃ´ hÃ¬nh partition)

**Äá»‹nh lÃ½ 5.5 (PhÃ¢n rÃ£ duy nháº¥t khi partition bit disjoint).** Náº¿u biá»ƒu diá»…n Ä‘Æ°á»£c tá»• chá»©c báº±ng cÃ¡c vÃ¹ng bit disjoint, má»—i primitive chiáº¿m má»™t táº­p bit riÃªng, thÃ¬ má»i (\mathbb{L}) cÃ³ phÃ¢n rÃ£ duy nháº¥t thÃ nh OR cÃ¡c primitives.

**Chá»©ng minh.** Tá»« tÃ­nh cháº¥t disjoint: Ã¡nh xáº¡ tá»« táº­p primitives â†’ táº­p bit lÃ  song toÃ n trÃªn miá»n Ä‘Ã£ Ä‘á»‹nh; OR cÃ¡c vÃ¹ng disjoint tÃ¡i táº¡o duy nháº¥t cÃ¡c bit. â–¡

---

## 6. MÃ´ hÃ¬nh lá»—i vÃ  há»‡ giáº£m sai sá»‘ (RNS, ECC, Dithering)

### 6.1 MÃ´ hÃ¬nh lá»—i thá»±c táº¿

Nguá»“n lá»—i:

* **Bit flips** do soft error / particle or hardware faults.
* **Carry overflow** giá»¯a phÃ¢n Ä‘oáº¡n khi guard khÃ´ng Ä‘á»§.
* **Rounding/quantization error** do rá»i ráº¡c hoÃ¡ log/phase.

Thiáº¿t káº¿ pháº£i káº¿t há»£p guard, ECC, vÃ  cÆ¡ cháº¿ phÃ¡t hiá»‡n trÃ n.

### 6.2 Residue Number System (RNS)

LÆ°u cÃ¡c giÃ¡ trá»‹ lá»›n (nhÆ° (\tilde\rho) vá»›i pháº¡m vi lá»›n) theo RNS Ä‘á»ƒ trÃ¡nh carry chain vÃ  cho phÃ©p cá»™ng Ä‘á»™c láº­p giá»¯a cÃ¡c modulus. RNS há»¯u Ã­ch cho trÆ°á»ng há»£p cáº§n dynamic range lá»›n vÃ  high-throughput addition.

### 6.3 ECC & Parity Guards

TÃ¹y má»©c Ä‘á»™ rá»§i ro, dÃ¹ng BCH/LDPC cho guard Ä‘á»ƒ sá»­a nhiá»u bit; hoáº·c parity/gf-check cho overhead tháº¥p. PhÃ¢n vÃ¹ng há»£p lÃ½ ECC theo kÃ­ch thÆ°á»›c lá»—i mong Ä‘á»£i.

### 6.4 Dithering vÃ  Oversampling bit-domain

Äá»ƒ giáº£m aliasing do rá»i ráº¡c hoÃ¡ (vÃ­ dá»¥ gÃ³c), thá»±c hiá»‡n oversample ná»™i bá»™, ghi dÆ° sai sá»‘ vÃ o guard vÃ  Ã¡p dá»¥ng bit-shuffling Ä‘á»ƒ biáº¿n dáº¡ng sai sá»‘ thÃ nh noise tráº¯ng, dá»… lá»c.

---

## 7. Kiáº¿n trÃºc MPU: pháº§n cá»©ng vÃ  ISA

### 7.1 ThÃ nh pháº§n cá»‘t lÃµi

* **UWR (Ultra-Wide Register):** thanh ghi ráº¥t rá»™ng (tá»« vÃ i K Ä‘áº¿n vÃ i chá»¥c K bit), dÃ¹ng Ä‘á»ƒ thá»±c thi bitwise/op toÃ n frame trong má»™t láº§n.
* **Barrel Shifter Matrix:** há»— trá»£ shift lá»›n (cho translation) nhanh.
* **Phase Adder Array:** máº£ng cá»™ng song song thá»±c hiá»‡n add modulo cho phÃ¢n Ä‘oáº¡n pha/radius.
* **Bitwise Topology Engine:** AND/OR/NOT trÃªn toÃ n bá»™ UWR hoáº·c multi-chunk.
* **RNS/ECC Unit:** chuyá»ƒn Ä‘á»•i RNS, kiá»ƒm tra, sá»­a lá»—i.
* **Compression/Decompression:** streaming nÃ©n sparse structures (octree pruning).

### 7.2 ISA Ä‘á» xuáº¥t (má»™t sá»‘ lá»‡nh máº«u)

`LOAD_UWR`, `STORE_UWR`, `BLOCK_SHIFT(offset)`, `ROTATE_MASK_ADD(v,o_phi)`, `BITWISE_AND`, `BITWISE_OR`, `BROADCAST_PHASE(v)`, `RNS_ADD`, `ECC_CHECK`, `DECOMPRESS_STREAM`.

### 7.3 Giao tiáº¿p bá»™ nhá»›

Thiáº¿t káº¿ dá»±a trÃªn streaming/DMA: lÆ°u biá»ƒu diá»…n nÃ©n trÃªn DRAM/SSD, giáº£i nÃ©n trá»±c tiáº¿p vÃ o UWR Ä‘á»ƒ thá»±c thi. Scheduler Æ°u tiÃªn locality frame Ä‘á»ƒ giáº£m I/O.

---

## 8. PhÃ¢n tÃ­ch Ä‘á»™ phá»©c táº¡p & bÄƒng thÃ´ng

KÃ½ hiá»‡u: (m) sá»‘ bit cáº§n xá»­ lÃ½ cho Ä‘á»‘i tÆ°á»£ng, (W) kÃ­ch thÆ°á»›c UWR.

* Náº¿u (m\le W) (Ä‘á»‘i tÆ°á»£ng vá»«a trong UWR): nhiá»u phÃ©p boolean vÃ  mask-add lÃ  O(1) (vá» sá»‘ tá»«), Ä‘á»™ trá»… háº±ng sá»‘.
* Náº¿u (m>W): cáº§n chia thÃ nh (\lceil m/W\rceil) chunk â†’ chi phÃ­ tuyáº¿n tÃ­nh theo sá»‘ chunk.

Tá»•ng thá»i gian thá»±c táº¿:
[ T_{total}=T_{io}(m)+T_{compute}(\lceil m/W\rceil)+T_{post},]
trong Ä‘Ã³ (T_{io}) chiáº¿m pháº§n lá»›n náº¿u nÃ©n/giáº£i nÃ©n.

So sÃ¡nh vá»›i GPU: cho cÃ¡c workload boolean/voxel-heavy, mÃ´ hÃ¬nh bit-parallel cÃ³ thá»ƒ giáº£m sá»‘ vÃ²ng Ä‘á»c-ghi vÃ  táº­n dá»¥ng bÃ­t song song; nhÆ°ng cho shading FP hoáº·c mesh-heavy, GPU váº«n hiá»‡u quáº£ hÆ¡n.

---

## 9. Giao diá»‡n rendering: Bitâ†’Pixel vÃ  Neural Bit-Decoder (NBD)

### 9.1 Bit-to-Pixel cÆ¡ báº£n

QuÃ©t occupancy theo ordering (Morton/Hilbert) Ä‘á»ƒ táº¡o tile framebuffer. Náº¿u mÃ´-Ä‘un hiá»ƒn thá»‹ há»— trá»£ streaming bit, cÃ³ thá»ƒ direct-drive; trong háº§u háº¿t há»‡, cáº§n intermediate tile buffer.

### 9.2 Neural Bit-Decoder (NBD)

NBD nháº­n cÃ¡c bit-patch (vÃ­ dá»¥ 32Ã—32 bits) vÃ  dá»± Ä‘oÃ¡n tile RGB/alpha. Lá»£i Ã­ch: há»c Ä‘Æ°á»£c ná»™i suy bá» máº·t tá»« cáº¥u trÃºc bitâ€”cáº£i thiá»‡n mÆ°á»£t, giáº£m artifacts so vá»›i map trá»±c tiáº¿p. CÃ¡c metric: SSIM/LPIPS, latency, throughput.

---

## 10. Háº¡n cháº¿, rá»§i ro vÃ  pháº¡m vi á»©ng dá»¥ng

**Háº¡n cháº¿:** tÄƒng bá»™ nhá»› theo Ä‘á»™ phÃ¢n giáº£i (curse of dimensionality), phá»¥ thuá»™c vÃ o sparsity, giá»›i háº¡n khi cáº§n phÃ©p toÃ¡n ná»™i suy chÃ­nh xÃ¡c (perspective-correct).

**Rá»§i ro:** khÃ´ng pháº£i panacea; khÃ´ng phÃ¹ há»£p cho shading phá»©c táº¡p, physics-based rendering yÃªu cáº§u FP.

**Pháº¡m vi phÃ¹ há»£p:** CSG/CAD, voxel rendering, collision, spatial index, procedural generation server-side.

---

## 11. Káº¿ hoáº¡ch thÃ­ nghiá»‡m vÃ  benchmark (chi tiáº¿t hÆ¡n)

**Giai Ä‘oáº¡n A â€” Prototype pháº§n má»m (4â€“8 tuáº§n)**

* Triá»ƒn khai reference library C++/Rust: `LIGA::Pack/Unpack`, `ApplyRotationMask`, `CSG ops`, `RNS module`, ECC simulation.
* Test datasets: Stanford Bunny (voxelized), CAD models boolean-heavy, synthetic sparse/dense scenes.
* Metrics: latency per-op, memory, accuracy (Hamming distance so vá»›i ground-truth voxelization), energy (simulated).

**Giai Ä‘oáº¡n B â€” Validation to proof conditions (6â€“10 tuáº§n)**

* Kiá»ƒm tra guard-safe: xÃ¢y bá»™ test chuá»—i phÃ©p cá»™ng Ä‘á»ƒ tÃ¬m carry cross-segment.
* Thá»­ RNS/ECC: inject faults, Ä‘o tá»‰ lá»‡ sá»­a thÃ nh cÃ´ng/latent error.

**Giai Ä‘oáº¡n C â€” FPGA prototype (12â€“20 tuáº§n)**

* Map UWR-chunks, Barrel Shifter, Phase Adder Array lÃªn FPGA logic.
* Äo throughput, latency, nÄƒng lÆ°á»£ng; benchmark vá»›i GPU (RTX) cho workloads boolean/voxel.

**Giai Ä‘oáº¡n D â€” NBD & pipeline (8â€“12 tuáº§n)**

* Train NBD tá»« bit patchesâ†’tile images; so sÃ¡nh cháº¥t lÆ°á»£ng vá»›i rasterization.
* End-to-end latency Ä‘o tá»« LIGA representation â†’ framebuffer.



**Má»™t vÃ­ dá»¥ cho viá»‡c LIGA giáº£i bÃ i toÃ¡n n-chiá»u (nD) :**

MÃ´ táº£ váº¥n Ä‘á» nD : Giáº£ sá»­ ta cÃ³ má»™t táº­p S gá»“m N â€œtile framesâ€, má»—i tile lÃ  má»™t Ã´ occupancy trong má»™t lÆ°á»›i rá»i ráº¡c kÃ­ch thÆ°á»›c 2^d theo má»—i chiá»u (tá»©c tá»•ng cells = 2^(d.n) â€” biá»ƒu diá»…n cá»±c lá»›n khi n tÄƒng). Ta muá»‘n thá»±c hiá»‡n má»™t phÃ©p quay rá»i ráº¡c cÃ¹ng gÃ³c Î”Î¸ lÃªn táº¥t cáº£ tile frames (hoáº·c táº¥t cáº£ nodes cá»§a má»™t octree/quadtree á»Ÿ má»i vá»‹ trÃ­) Ä‘á»“ng thá»i â€” tá»©c thay Ä‘á»•i trÆ°á»ng pha ğœ‘ cá»§a má»—i frame báº±ng cÃ¹ng má»™t offset.

Vá»›i cáº¥u trÃºc PFE cá»§a LIGA, náº¿u báº¡n Ä‘Ã³ng gÃ³i N frames liÃªn tiáº¿p (má»—i frame cÃ³ phÃ¢n Ä‘oáº¡n pha ğœ‘ náº±m á»Ÿ offset cá»‘ Ä‘á»‹nh trong PFE) thÃ¬ má»™t phÃ©p cá»™ng nguyÃªn duy nháº¥t:

$$\mathbb{L}' = (\mathbb{L} + M(v)) \bmod 2^{NW}$$

vá»›i M(v) lÃ  mask-add Ä‘Ã£ Ä‘á»‹nh nghÄ©a (Ä‘áº·t giÃ¡ trá»‹ v vÃ o vá»‹ trÃ­ phÃ¢n Ä‘oáº¡n pha cá»§a má»—i frame), sáº½ xoay táº¥t cáº£ N frame cÃ¹ng lÃºc â€” tá»©c thá»±c hiá»‡n N phÃ©p xoay Ä‘á»™c láº­p chá»‰ báº±ng má»™t addition (má»™t chuá»—i bitwise add) náº¿u layout guard-safe.




---

## 12. Káº¿t luáº­n vÃ  hÆ°á»›ng phÃ¡t triá»ƒn

LIGA lÃ  má»™t khuÃ´n káº¿t há»£p toÃ¡n há»c vÃ  kiáº¿n trÃºc dÃ nh cho cÃ¡c bÃ i toÃ¡n hÃ¬nh thÃ¡i rá»i ráº¡c. TÃ i liá»‡u nÃ y lÃ m rÃµ cÃ¡c Ä‘iá»u kiá»‡n toÃ¡n há»c khi cÃ¡c phÃ©p biáº¿n Ä‘á»•i Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng thao tÃ¡c bit/aritmetic phÃ¢n Ä‘oáº¡n lÃ  Ä‘Ãºng; cung cáº¥p mÃ´ hÃ¬nh lá»—i vÃ  cÆ¡ cháº¿ sá»­a chá»¯a cáº§n thiáº¿t Ä‘á»ƒ Ä‘áº¡t tÃ­nh tin cáº­y; Ä‘á»“ng thá»i Ä‘á» xuáº¥t kiáº¿n trÃºc MPU Ä‘á»ƒ Ä‘áº¡t hiá»‡u nÄƒng. BÆ°á»›c tiáº¿p theo lÃ  thá»±c hiá»‡n prototype pháº§n má»m vÃ  pháº§n cá»©ng Ä‘á»ƒ chá»©ng minh cáº£i tiáº¿n thá»±c nghiá»‡m.

---

# Appendices

## Appendix A â€” Pseudocode cÆ¡ báº£n (máº«u)

```text
function packPFE(frameList):
  L = 0
  for k, frame in enumerate(frameList):
    pfe = (guardBits(frame) << (s+r+phi)) |
          (state(frame) << (r+phi)) |
          (rho_enc(frame) << phi) |
          (phi_enc(frame))
    L |= pfe << (k*W)
  return L

function applyRotationMask(L, v):
  M = 0
  for k in 0..N-1:
    M |= v << (k*W + o_phi)
  return (L + M) mod 2^(N*W)

function csgAND(LA, LB):
  return LA & LB




**Run the test:**

liga_demo.py: 
"
#!/usr/bin/env python3
# liga_demo.py
# Demo LIGA packing + mask-add rotation vs baseline vectorized update
# Requires: Python 3.8+, numpy

import time
import numpy as np
from typing import List, Tuple

# ---------------------------
# Layout / parameters (configurable)
# ---------------------------
W = 64               # bits per PFE (choose >= sum of fields)
phi_bits = 10        # width of phase field (phi)
rho_bits = 12        # width of radius field (rho)
state_bits = 6       # width for state
guard_bits = W - (phi_bits + rho_bits + state_bits)  # remaining bits as guard
o_phi = 0            # offset of phi inside PFE (LSB position) -> we'll put phi in LSB zone

MASK_phi = (1 << phi_bits) - 1

# Check guard-safety helper
def is_guard_safe(max_stack_additions: int) -> bool:
    # Condition (simplified): guard_bits > floor(log2(max_stack_additions))
    import math
    if max_stack_additions <= 0:
        return True
    return guard_bits > math.floor(math.log2(max_stack_additions))

# ---------------------------
# Pack / Unpack
# ---------------------------
def pack_frames(frames: List[Tuple[int,int,int]]) -> int:
    """
    frames: list of tuples (phi, rho, state) with widths as above
    returns big-int L which packs PFE_0 at least significant W bits, PFE_1 next, ...
    """
    L = 0
    for k, (phi, rho, state) in enumerate(frames):
        # clamp
        phi &= MASK_phi
        rho &= ((1 << rho_bits) - 1)
        state &= ((1 << state_bits) - 1)
        pfe = ( ( ( (state << (rho_bits + phi_bits)) |
                   (rho << phi_bits) ) |
                   phi ) )
        L |= (pfe << (k * W))
    return L

def unpack_frames(L: int, N: int) -> List[Tuple[int,int,int]]:
    frames = []
    mask_pfe = (1 << W) - 1
    for k in range(N):
        pfe = (L >> (k * W)) & mask_pfe
        phi = pfe & MASK_phi
        rho = (pfe >> phi_bits) & ((1 << rho_bits) - 1)
        state = (pfe >> (phi_bits + rho_bits)) & ((1 << state_bits) - 1)
        frames.append((phi, rho, state))
    return frames

# ---------------------------
# LIGA rotation via mask-add
# ---------------------------
def build_phase_mask(N: int, v: int) -> int:
    """Build M(v) = sum_k (v << (k*W + o_phi)). Precompute once."""
    v &= MASK_phi
    M = 0
    # efficient loop; still O(N) to build mask, but reused across iterations
    for k in range(N):
        M |= (v << (k * W + o_phi))
    return M

def apply_rotation_mask(L: int, M: int, total_bits: int) -> int:
    """Perform (L + M) mod 2^(total_bits). total_bits = N*W"""
    mod = 1 << total_bits
    return (L + M) % mod

# ---------------------------
# Baseline: per-frame vectorized update (numpy)
# ---------------------------
def baseline_vectorized(phi_array: np.ndarray, v: int) -> None:
    # phi_array is numpy array of dtype uint32 or similar
    phi_array[:] = (phi_array + np.uint32(v)) & np.uint32(MASK_phi)

# ---------------------------
# Micro-benchmark harness
# ---------------------------
def benchmark(N=2000, iterations=200, show_unpacked_check=False):
    print(f"\n--- LIGA demo: N={N}, W={W}, phi_bits={phi_bits}, iterations={iterations}")
    print(f"Guard bits = {guard_bits}. Guard-safe for stacking 1e6 additions? {is_guard_safe(10**6)}")

    # Random synthetic frames
    rng = np.random.default_rng(12345)
    phi_vals = rng.integers(low=0, high=(1<<phi_bits), size=N, dtype=np.uint32)
    rho_vals = rng.integers(low=0, high=(1<<rho_bits), size=N, dtype=np.uint32)
    state_vals = rng.integers(low=0, high=(1<<state_bits), size=N, dtype=np.uint32)
    frames = list(zip(map(int, phi_vals), map(int, rho_vals), map(int, state_vals)))

    # pack
    t0 = time.perf_counter()
    L = pack_frames(frames)
    t1 = time.perf_counter()
    build_M_v = 7  # chosen rotation delta
    M = build_phase_mask(N, build_M_v)
    t2 = time.perf_counter()
    pack_time = t1 - t0
    mask_build_time = t2 - t1
    print(f"pack time: {pack_time:.6f}s, build_mask time: {mask_build_time:.6f}s")

    # Warm up baseline arrays
    phi_array = phi_vals.copy()

    # Benchmark LIGA add (single big-int add per iteration)
    total_bits = N * W
    start = time.perf_counter()
    L2 = L
    for i in range(iterations):
        L2 = apply_rotation_mask(L2, M, total_bits)
    end = time.perf_counter()
    liga_time = end - start
    print(f"LIGA mask-add: total {iterations} iterations -> {liga_time:.6f}s ; avg {liga_time/iterations:.9f}s per add")

    # Benchmark baseline vectorized
    start = time.perf_counter()
    phi_copy = phi_array.copy()
    for i in range(iterations):
        baseline_vectorized(phi_copy, build_M_v)
    end = time.perf_counter()
    base_time = end - start
    print(f"Baseline vectorized (numpy) {iterations} iterations -> {base_time:.6f}s ; avg {base_time/iterations:.9f}s per step")

    # For fairness: include a pure Python loop baseline (per-frame loop) to show huge difference
    start = time.perf_counter()
    phi_py = list(map(int, phi_vals))
    for i in range(iterations):
        for j in range(N):
            phi_py[j] = (phi_py[j] + build_M_v) & MASK_phi
    end = time.perf_counter()
    py_loop_time = end - start
    print(f"Baseline pure-Python loop {iterations} iterations -> {py_loop_time:.6f}s ; avg {py_loop_time/iterations:.9f}s per step")

    # Optional: verify correctness (unpack L2 and compare phi fields to baseline result)
    if show_unpacked_check:
        unpacked = unpack_frames(L2, N)
        phi_unpacked = np.array([p for (p,_,_) in unpacked], dtype=np.uint32)
        # expected phi after iterations
        expected_phi = (phi_vals + iterations * np.uint32(build_M_v)) & np.uint32(MASK_phi)
        eq = np.all(phi_unpacked == expected_phi)
        print(f"Correctness check (LIGA vs expected): {eq}")
        if not eq:
            print("Example mismatch (first 10):")
            print("unpacked:", phi_unpacked[:10])
            print("expected:", expected_phi[:10])

if __name__ == "__main__":
    # Example runs with different sizes; uncomment the one you want:
    benchmark(N=2000, iterations=500, show_unpacked_check=True)
    # benchmark(N=10000, iterations=200, show_unpacked_check=False)
"


Result :
"
C:\Users\Admin\D - Storage\LIGA>python liga_demo.py --- LIGA demo: N=2000, W=64, phi_bits=10, iterations=500 Guard bits = 36. Guard-safe for stacking 1e6 additions? True pack time: 0.002836s, build_mask time: 0.002100s LIGA mask-add: total 500 iterations -> 0.001888s ; avg 0.000003777s per add Baseline vectorized (numpy) 500 iterations -> 0.002308s ; avg 0.000004616s per step Baseline pure-Python loop 500 iterations -> 0.075062s ; avg 0.000150124s per step Correctness check (LIGA vs expected): True
"

```

## Appendix B â€” VÃ­ dá»¥ numeric (carry/guard minh hoáº¡)

Cho W=32, phi=8, rho=8, s=4, g=12. Náº¿u ta cá»™ng v=200 vÃ o phi, giáº£ sá»­ phi byte cÃ³ giÃ¡ trá»‹ 100. VÃ¬ phi width=8, (100+200)=300 â‰¡ 44 (mod 256), carry=1 nhÆ°ng guard g=12 Ä‘á»§ Ä‘á»ƒ cÃ´ láº­p carry náº¿u ta Ä‘áº£m báº£o carry khÃ´ng lan rá»™ng hÆ¡n 1 vÃ o vÃ¹ng guard (vÃ  guard thiáº¿t káº¿ Ä‘á»ƒ cáº¯t carry).

## Appendix C â€” Tháº£o luáº­n trade-offs

* **Guard bits vs density:** thÃªm guard giáº£m carry risk nhÆ°ng tÄƒng overhead bá»™ nhá»›.
* **RNS vs linear encoding:** RNS giÃºp trÃ¡nh carry chain nhÆ°ng phá»©c táº¡p khi so sÃ¡nh/decoding.
* **UWR width:** cÃ ng lá»›n cÃ ng nhiá»u parallelism nhÆ°ng tÄƒng chi phÃ­ routing vÃ  I/O.



---

